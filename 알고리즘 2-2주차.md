## 점화식 

점화식: 어떤 함수(보통 입력 변수를 n 등의 미지수로 표현)를 **자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 식**

점화식 예시 

1. an = an-1 + 2

2. f(n) = n f(n−1)

3. f(n) = f(n−1) + f(n−2)

4. f(n) = f(n/2) + n

<br/>

## 병합 정렬 및 점화식 

```ruby
mergeSort(A[ ], p, r)      ▷ A[p...r]을 정렬한다.
{
    if (p < r) then {
        q ← (p + r) / 2      ▷ p, q의 중간 지점 계산
        mergeSort(A, p, q)    ▷ 전반부 정렬
        mergeSort(A, q + 1, r) ▷ 후반부 정렬
        merge(A, p, q, r)      ▷ 병합
    }
}

merge(A[ ], p, q, r) 
{
    ▷ 정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여 정렬된 하나의 배열 A[p...r]을 만든다.
}
```
**병합 정렬 (mergeSort)** 는 배열 A[p...r]을 정렬하는 함수이다

**수행 시간의 점화식: T(n) = 2T(n/2)+ 오버헤드**

-> 크기가 n인 병합 정렬 시간은 크기가 n/2인 병합 정렬을 두 번하는 시간과 나머지 오버헤드를 더한 시간임

<br/>

병합 정렬 과정:

1. r이 p보다 크면 배열을 반으로 나눈다. q ← (p + r) / 2에서 q는 배열의 중간 인덱스

2. 배열을 두 개의 부분 배열로 나누어 각각 병합 정렬을 재귀적으로 호출

3. mergeSort(A, p, q) : 배열의 전반부 (A[p...q])를 정렬

4. mergeSort(A, q + 1, r) : 배열의 후반부 (A[q+1...r])를 정렬

5. 두 부분 배열이 정렬되면 merge(A, p, q, r) 함수가 두 배열을 병합하여 하나의 정렬된 배열을 만듦

위 과정에서 merge(A[ ], p, q, r) 이 함수가 병합 및 정렬을 담당함 

<br/> 

## 예시 

예시 배열: [8, 3, 1, 7, 2, 6, 5, 4]

**1. 배열을 반으로 나누기**

[8, 3, 1, 7] 와 [2, 6, 5, 4]

<br/>

**2. 재귀적으로 분할**

[8, 3, 1, 7] -> [8, 3] 와 [1, 7]

[2, 6, 5, 4] -> [2, 6] 와 [5, 4]

<br/>

**3. 내림차순으로 정렬된 작은 배열들**

[8, 3] -> [8, 3]

[1, 7] -> [7, 1]

[2, 6] -> [6, 2]

[5, 4] -> [5, 4]

<br/>

**4. 병합 (두 배열씩 합치기)**


[8, 3]와 [7, 1] 병합 -> [8, 7, 3, 1]
 
[6, 2]와 [5, 4] 병합 -> [6, 5, 4, 2]

<br/>

**5. 최종 병합**

[8, 7, 3, 1]와 [6, 5, 4, 2] 병합 -> [8, 7, 6, 5, 4, 3, 2, 1]

**최종 정렬된 배열 (내림차순): [8, 7, 6, 5, 4, 3, 2, 1]**

<br/>

**병합하는 과정은 O(n)만큼 소요됨**

O(n) 시간이 걸리는 이유는 이 함수가 두 개의 정렬된 배열을 하나의 정렬된 배열로 병합하는 과정에서 **각 원소를 한 번씩만 비교하고 배치하기 때문**

ex) 

[1,3,8], [5,7,9] 병합 

1,5 비교 -> 1 선택

3,5 비교 -> 3 선택

8,5 비교 -> 5 선택

8,7 비교 -> 7 선택 

8,9 비교 -> 8 선택

9 -> 9 선택 

총 6개 원소를 6번 계산함 -> 이것을 일반화하면 n개 원소를 n번 계산 -> O(n)

<br/>

## 점화식의 점근적 분석 방법 종류 

1. **반복 대치** : 점화식을 더 작은 문제에 대한 함수로 반복해서 대치해나가며 분석하는 방법

2. **추정 후 증명** : 해당 점화식의 복잡도에 대해 추정한 후 수학적 귀납법으로 증명하는 방법

3. **마스터 정리** : 점화식 형태에 따른 복잡도를 바로 계산할 수 있는 방법

<br/>

## 반복 대치 및 factorial 예시 

![스크린샷 2025-03-16 163949](https://github.com/user-attachments/assets/9fd26960-68af-4a27-a628-19cbec5b69c6)

c는 if문, 반환 구문 및 곱셈 수행시간을 합친 연산시간이므로 T(1) = factorial(1)보다 큼 

<br/>

## 반복 대치 및 병합 정렬 예시 

![image](https://github.com/user-attachments/assets/b179de1a-c543-4598-ad61-710a157c16e0)

T(1) = 1 인 이유는 병합 정렬에서 n = 1이면 정렬할 필요가 없으므로 상수 시간 O(1)만큼 걸린다 









































