## 점화식 

점화식: 어떤 함수(보통 입력 변수를 n 등의 미지수로 표현)를 **자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 식**

점화식 예시 

1. an = an-1 + 2

2. f(n) = n f(n−1)

3. f(n) = f(n−1) + f(n−2)

4. f(n) = f(n/2) + n

<br/>

## 병합 정렬 및 점화식 

```ruby
mergeSort(A[ ], p, r)      ▷ A[p...r]을 정렬한다.
{
    if (p < r) then {
        q ← (p + r) / 2      ▷ p, q의 중간 지점 계산
        mergeSort(A, p, q)    ▷ 전반부 정렬
        mergeSort(A, q + 1, r) ▷ 후반부 정렬
        merge(A, p, q, r)      ▷ 병합
    }
}

merge(A[ ], p, q, r) 
{
    ▷ 정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여 정렬된 하나의 배열 A[p...r]을 만든다.
}
```
**병합 정렬 (mergeSort)** 는 배열 A[p...r]을 정렬하는 함수이다

**수행 시간의 점화식: T(n) = 2T(n/2)+ 오버헤드**

-> 크기가 n인 병합 정렬 시간은 크기가 n/2인 병합 정렬을 두 번하는 시간과 나머지 오버헤드를 더한 시간임

<br/>

병합 정렬 과정:

1. r이 p보다 크면 배열을 반으로 나눈다. q ← (p + r) / 2에서 q는 배열의 중간 인덱스

2. 배열을 두 개의 부분 배열로 나누어 각각 병합 정렬을 재귀적으로 호출

3. mergeSort(A, p, q) : 배열의 전반부 (A[p...q])를 정렬

4. mergeSort(A, q + 1, r) : 배열의 후반부 (A[q+1...r])를 정렬

5. 두 부분 배열이 정렬되면 merge(A, p, q, r) 함수가 두 배열을 병합하여 하나의 정렬된 배열을 만듦

위 과정에서 merge(A[ ], p, q, r) 이 함수가 병합 및 정렬을 담당함 

<br/> 

## 예시 

예시 배열: [8, 3, 1, 7, 2, 6, 5, 4]

**1. 배열을 반으로 나누기**

[8, 3, 1, 7] 와 [2, 6, 5, 4]

<br/>

**2. 재귀적으로 분할**

[8, 3, 1, 7] -> [8, 3] 와 [1, 7]

[2, 6, 5, 4] -> [2, 6] 와 [5, 4]

<br/>

**3. 내림차순으로 정렬된 작은 배열들**

[8, 3] -> [8, 3]

[1, 7] -> [7, 1]

[2, 6] -> [6, 2]

[5, 4] -> [5, 4]

<br/>

**4. 병합 (두 배열씩 합치기)**


[8, 3]와 [7, 1] 병합 -> [8, 7, 3, 1]
 
[6, 2]와 [5, 4] 병합 -> [6, 5, 4, 2]

<br/>

**5. 최종 병합**

[8, 7, 3, 1]와 [6, 5, 4, 2] 병합 -> [8, 7, 6, 5, 4, 3, 2, 1]

**최종 정렬된 배열 (내림차순): [8, 7, 6, 5, 4, 3, 2, 1]**

<br/>

**병합하는 과정은 O(n)만큼 소요됨**

O(n) 시간이 걸리는 이유는 이 함수가 두 개의 정렬된 배열을 하나의 정렬된 배열로 병합하는 과정에서 **각 원소를 한 번씩만 비교하고 배치하기 때문**

ex) 

[1,3,8], [5,7,9] 병합 

1,5 비교 -> 1 선택

3,5 비교 -> 3 선택

8,5 비교 -> 5 선택

8,7 비교 -> 7 선택 

8,9 비교 -> 8 선택

9 -> 9 선택 

총 6개 원소를 6번 계산함 -> 이것을 일반화하면 n개 원소를 n번 계산 -> O(n)

<br/>

또한 병합 정렬은 처음 분리를 하는 리스트를 루트 노드라고 하면 루트 노드의 왼쪽 서브트리가 모두 정렬이 되고, 이후 오른족 서브 트리가 모두 정렬이 되는 방식이다 

**예시**
```ruby
 merge(1,4,8)
                          /            \
              merge(1,2,4)              merge(5,6,8)
             /           \             /           \
    merge(1,1,2)      merge(3,3,4)  merge(5,5,6)   merge(7,7,8)
     /     \           /     \      /     \         /     \
 (1,1)   (2,2)     (3,3)   (4,4)  (5,5)  (6,6)    (7,7)   (8,8)
```

1. (1,1), (2,2) → merge(1,1,2)

2. (3,3), (4,4) → merge(3,3,4)

3. merge(1,2,4) ← 왼쪽 하위 병합 완료

4. (5,5), (6,6) → merge(5,5,6)

5. (7,7), (8,8) → merge(7,7,8)

6. merge(5,6,8) ← 오른쪽 하위 병합 완료

7. merge(1,4,8) ← 최종 병합

<br/>

## 점화식의 점근적 분석 방법 종류 

1. **반복 대치** : 점화식을 더 작은 문제에 대한 함수로 반복해서 대치해나가며 분석하는 방법

2. **추정 후 증명** : 해당 점화식의 복잡도에 대해 추정한 후 수학적 귀납법으로 증명하는 방법

3. **마스터 정리** : 점화식 형태에 따른 복잡도를 바로 계산할 수 있는 방법

<br/>

## 반복 대치 및 factorial 예시 

![스크린샷 2025-03-16 163949](https://github.com/user-attachments/assets/9fd26960-68af-4a27-a628-19cbec5b69c6)

c는 if문, 반환 구문 및 곱셈 수행시간을 합친 연산시간이므로 T(1) = factorial(1)보다 큼 

<br/>

## 반복 대치 및 병합 정렬 예시 

![image](https://github.com/user-attachments/assets/b179de1a-c543-4598-ad61-710a157c16e0)

T(1) = 1 인 이유는 병합 정렬에서 n = 1이면 정렬할 필요가 없으므로 상수 시간 O(1)만큼 걸린다 

<br/>

## 추정 후 증명 

![image](https://github.com/user-attachments/assets/45955515-7d54-4777-85ea-6e585a930579)

<br/>

**순서**

1. 귀납적 가정 : 먼저, n = k 일 때 성립한다고 가정합니다. 즉, T(k) ≤ c ⋅ k log k가 성립한다고 가정
  
2. 기본 단계 : 가장 작은 값(예:n=1 또는 n=2)에 대해 명제가 참인지 확인. 즉, 귀납법을 시작하기 위한 출발점을 설정하는 단계

3. 귀납적 가정 및 전개 : 다음 단계를 기준으로 값을 설정하여 판단 

<br/>

일반적인 귀납법에서는 n = k 가 참이라면, n = k + 1도 참임을 이용하여 증명했지만, 위 병합 정렬에서는 n 다음 단계가 n/2 이다 

따라서 k + 1 역할을 n/2가 하기 때문에 n/2에 대해 증명을 해야한다 

또한 k = 1 이 아니라 k = 2에 대해 증명한 이유는 병합 정렬에서 최소 단위가 2이기 때문이다 (1이면 요소 하나를 다른 값과 비교 불가능)

따라서 병합 정렬에서 가장 작은 값인 2로 명제가 참인지 확인함

<br/>

## 순서 설명 

먼저 추정에서 예상을 함 

c는 어떤 상수이고, log 2 = 1 이므로 T(2) ≤ 2c이다 이때, T(2)는 병합 정렬이 2개의 요소를 정렬하는 데 걸리는 시간인데, 이는 어떤 상수 값이므로 등호를 만족하는 c가 존재함 -> 귀납법의 기본 단계가 완료됨 

그 후 점화식 n/2에 대해 식을 세워서 성립함을 확인 

**마지막에 반드시 c의 범위를 명시해야함**

<br/>

## 마스터 정리 

![image](https://github.com/user-attachments/assets/e6c3c7c3-01dd-4b25-a815-00a717c8c931)

<br/>

## 마스터 정리 직관적 해석 

1. h(n)이 더 무거우면 h(n)이 수행 시간을 결정한다

2. f(n)이 더 무거우면 f(n)이 수행 시간을 결정한다

3. h(n)과 f(n)이 같은 무게이면 h(n)에 logn을 곱한 것이 수행 시간이 된다

여기서 조심해야할 부분은

마스터 정리 첫번째 유형의 f(n)/h(n) = O(1/nε) 는 단순히 h(n)이 더 무겁다는 것이 아니라, h(n)이 f(n)을 적어도 **다항식의 비율**로 압도한다는 의미

예를 들어, f(n)/h(n) = O(1/ logn) 이 되면 마스터 정리 첫번째 항에 해당하지 않음, 지수함수는 가능 

**즉, n의 k제곱(k는 양수이기만 하면 됨. 즉 k자리에 로그도 가능)** 을 만족하면 마스터 정리 이용가능 

<br/>

이와 유사하게 마스터 정리 두번째 유형도 단순히 f(n)이 더 무겁다는 것이 아니라 **다항식 비율**이상으로 무겁다는 것을 의미함

<br/>

마스터 정리에서의 f(n)은 재귀 알고리즘에서 발생하는 오버헤드에 해당하며, h(n)은 반복되는 재귀 호출로 인해 base case까지 가는 총 호출횟수에 해당한다

재귀적 호출의 소요시간이 오버헤드를 압도한다면 알고리즘의 수행시간은 h(n)이 결정

반대로 오버헤드가 더 크다면 f(n)이 알고리즘의 수행시간을 결정함

<br/>

## 마스터 정리 적용 예시 

![스크린샷 2025-03-25 114613](https://github.com/user-attachments/assets/ce8545c9-639e-42f1-bf30-7c97c96748a4)

<br/>

## 마스터 정리 적용 심화 

![스크린샷 2025-03-25 114623](https://github.com/user-attachments/assets/f5de7276-e9f7-4d42-9fac-e738dac263e6)

<br/>

## 퀴즈 1 

![스크린샷 2025-03-25 114628](https://github.com/user-attachments/assets/314d5658-750c-4e6f-9ab9-60539e4224ce)

<br/>

## 풀이

![IMG_3062](https://github.com/user-attachments/assets/072bc17c-ac65-45ec-8141-7fe487cbb12a)

<br/>

## 퀴즈 2

![스크린샷 2025-03-25 114634](https://github.com/user-attachments/assets/7355e901-ca75-4149-87ce-26aff2d7fa22)

<br/>

## 풀이

![IMG_3063](https://github.com/user-attachments/assets/2c7a7e88-6b32-4c81-b5c9-b0253a535427)

<br/>

## 퀴즈 3 

![스크린샷 2025-03-25 114638](https://github.com/user-attachments/assets/bec9bca1-d44c-40e5-b467-d8080c71598e)

<br/>

## 풀이 

![IMG_3064](https://github.com/user-attachments/assets/094b6a47-94be-4e01-92b2-18559e7f55fb)





















