## Heap

Heap은 complete binary tree(완전 이진 트리)로써 맨 아래 층을 제외하고는 완전히 채워져 있고, 맨 아래층은 왼쪽부터 채워져 있는 구조이다 

heap sort(힙 정렬)은 주어진 배열을 heap으로 만든 후 최대값 또는 최솟값을 하나씩 빼가며 한 방향으로 쌓아서 정렬함

<br/>

## heap 과정 

1. 힙 성질에 관해 문제가 생길 수 있으므로 가장 마지막에 있는 부모 원소부터 시작 (= n/2번째 노드)

2. 이후 더 작은 인덱스의 노드로 하나씩 옮겨가며 위 과정 반복

3. 최대 힙 또는 최소 힙의 조건의 위배되는 부모 노드와 자식 노드를 바꾸고, 위배를 한 부모노드가 자식 노드가 될 때, 해당 노드의 자식 노드를 검사하여 위배되면 바꿈(위배가 안될 때까지 진행)

4. 루트 노드까지 도달하여 문제가 없음을 확인하면 종료 

<br/>

요약하면 배열로부터 힙을 만드는 과정은 n/2 인덱스 노드부터 첫 번째 인덱스 노드까지 해당 노드를 

루트로 하는 트리를 힙 성질을 만족하도록 변경하는 과정을 반복하면 된다

이와 같이 트리를 힙 성질을 만족하도록 변경하는 과정을 heapify라 함

<br/>

```ruby
 buildHeap(A[], n)   ▷A[1... n]을 힙으로 만든다 
{ 
    for i ← n/2 downto1 { 
        heapify(A, i, n);
    } 
}

heapify(A[], k, n)   ▷ A[k]를 루트로 하는 트리를 힙 성질을 만족하도록 수정한다.
                        이 때 A[k]의 두 자식 노드를 루트로 하는 트리들은 힙 성질을 만족한다고 가정한다.
 { 
} 
    left ←2k; right ←2k+1;
     if  (right ≤ n) then {
         if (A[left] > A[right]) then bigger ← left;
                                 else  bigger ← right;
     }
     else if  (left ≤ n) then bigger ← left;
     else return;

    if  (A[bigger] > A[k]) then {
        A[k] A[bigger]) 교환;
        heapify(A,bigger,n)
```

가장 아래에서부터 확인하는 이유는 부모 자식 관계에서 오류가 발생했을 때, 자식 노드를 정렬해서 가면 오류가 발생한 위치만 바꿔주면 됨 









































