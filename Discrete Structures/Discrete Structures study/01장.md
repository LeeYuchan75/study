### 명제 

- **명제** : 명제는 **참(True) 또는 거짓(False)** 둘 중 하나로 판별할 수 있는 서술문
     - 즉, 질문이나 명령은 명제가 될 수 없다 

<br/>

### 명제 예시 

- The Moon is made of green cheese. → 달이 녹색 치즈로 만들어졌다는 문장. 사실은 거짓이지만, 참/거짓을 판단할 수 있으므로 명제입니다.

- Trenton is the capital of New Jersey. → 트렌턴이 뉴저지 주의 수도라는 주장. 사실 참(True)입니다.

- Toronto is the capital of Canada. → 토론토가 캐나다의 수도라는 주장. 사실은 거짓(False, 수도는 오타와). 하지만 참/거짓 판별이 가능하므로 명제입니다.

- 1 + 0 = 1 → 수학적으로 참(True)이므로 명제.

-  0 + 0 = 2 → 수학적으로 거짓(False)이므로 명제.

<br/>

### 명제가 아닌 예시 

- Sit down! → 명령문. 참/거짓을 따질 수 없으므로 명제가 아님.

- What time is it? → 질문문. 역시 참/거짓이 없으므로 명제가 아님.

- x + 1 = 2 → 미지수 x 값에 따라 참/거짓이 달라지므로 불확정. 단일 명제가 아님.

- x + y = z → 변수 값이 정해지지 않아 참/거짓 판단 불가. 따라서 명제가 아님.

<br/>

### 명제 기호 

- Propositional Variables: p, q, r, s, 등등
     - 명제를 기호화할 때 p, q, r, s 같은 문자를 사용
 
     - ex : “The earth is round” → p 로 표현

- 항상 참인 명제를 T (Tautology, 항진명제)

- 항상 거짓인 명제를 F (Contradiction, 모순명제)

- Negation (¬): 부정. ex: “p가 참” → “¬p는 거짓”

- Conjunction (∧): 논리곱, “그리고(and)”

- Disjunction (∨): 논리합, “또는(or)”

- Implication (→): 함의, “만약 …라면 …이다 (if … then …)”

- Biconditional (↔): 쌍조건, “…일 때 그리고 그 경우에만 …이다 (if and only if, iff)”

아래에서 명제 기호를 하나씩 살펴보자 

<br/>

### 명제 기호를 배우는 이유 (시험 x)

- 컴퓨터는 결국 **0과 1(참/거짓)** 으로만 사고
    - 논리 기호는 바로 **불 대수(Boolean Algebra)** 와 연결되어, 프로그래밍/알고리즘/회로 설계의 기초가 됨

- 명확한 표현을 위함
    - 자연어(한국어/영어)는 모호할 수 있
    - ex: "비가 오면 길이 젖는다" 라는 문장은 말로하면 헷갈릴 여지가 있지만, p → q라고 쓰면 해석이 정확해짐
 
- 정리하면 논리 기호는 수학적 언어이자, 컴퓨터/회로/프로그래밍에서 직접 쓰이는 실질적인 도구이기 때문에 필요함

<br/>

### Negation (¬) : 부정

- 명제 p의 부정은 ¬p로 표시함
    - p가 참이면 ¬p는 거짓, p가 거짓이면 ¬p는 참
 
    - ex : p = “지구는 둥글다.” , ¬p = “지구가 둥글지 않다.”

![System Resources](../../images/Discrete%20Structures%20images/negation.png)

<br/>

### Conjunction (∧) : 논리곱

- 두 명제 p와 q를 동시에 만족해야 참. **그리고 (AND)** 를 의미
  
   - 아래는 예시이다 
   - p = “나는 집에 있다.”
   - q = “비가 온다.”
   - p ∧ q = “나는 집에 있고 비가 온다.

![System Resources](../../images/Discrete%20Structures%20images/conjunction.png)

<br/>

### Disjunction (논리합, ∨)

- 두 명제 중 하나 이상이 참이면 전체가 참. **또는 (OR)** 을 의미
    
    - 아래는 예시이다 
    - p = “나는 집에 있다.”
    - q = “비가 온다.”
    - p ∨ q = “나는 집에 있거나 비가 온다.”  

![System Resources](../../images/Discrete%20Structures%20images/disjunction.png)

<br/>

### XOR (배타적 OR)

- **XOR : 정확히 하나만 참일 때 참**

- 영어에서 "or(또는)"는 두 가지 의미가 존재한다
  
     - **포괄적 OR** : “CS202 또는 Math120을 들은 학생은 이 수업을 들을 수 있다”는 의미는, 두 과목 중 하나만 들어도 되고, 둘 다 들어도 가능 -> 이것이 **논리합(∨)**
 
     - **배타적 OR (XOR)** : “이 요리에 스프 또는 샐러드가 나온다”라고 하면, 스프와 샐러드를 동시에 주지는 않는다는 뜻
 
     
![System Resources](../../images/Discrete%20Structures%20images/XOR.png) 

<br/>

### Implication (→) : 함의

- **함의** : p와 q가 명제일 때, p → q는 조건문(implication, 함축)이라 함.
   
    - "만약 p라면, q이다" 라고 읽음
    - 쉽게 말해서 약속을 어기는 경우만 거짓
    - 예시
    - 비가 오면 우산을 쓰겠다”에서 비가 왔는데(참) 우산을 안 쓴다면(거짓) → 조건 위반(거짓).
    - 비가 안 오면(거짓) → 약속과 무관하므로 참으로 처리


- Implication(함의)에서는 현실적으로 말이 안 돼도 논리학에서는 진리표만 보고 참/거짓을 결정함
   
    - p → q의 의미는 오직 p와 q의 참/거짓 값에만 달려 있다

- 함의를 표현하는 다른 방법
     - if p, then q  
     - if p, q  
     - q unless ¬p  
     - q if p  
     - q whenever p  
     - q follows from p  

     - p implies q  
     - p only if q  
     - q when p  
     - p is sufficient for q  
     - q is necessary for p  

     - a necessary condition for p is q  
     - a sufficient condition for q is p  

<br/>

### Converse (역), Inverse (이), Contrapositive (대우)

- 원래 명제: p → q

  - 역(Converse): q → p (자리 바꿈)
  - 이(Inverse): ¬p → ¬q (둘 다 부정)
  - 대우(Contrapositive): ¬q → ¬p (둘 다 부정 + 자리 바꿈 → 원래와 동치)

- 예시 : 비가 오면 나는 마을에 가지 않는다.” (p → q)
    - **Converse (역)**: If I do not go to town, then it is raining.
    - “내가 마을에 가지 않으면, 비가 온다.”
    - (전제/결론 순서를 바꾼 것)

    <br/>
    
    - **Inverse (이)**: If it is not raining, then I will go to town.
    - “비가 오지 않으면, 나는 마을에 간다.”
    - (둘 다 부정)

    <br/>
    
    - **Contrapositive (대우)**: If I go to town, then it is not raining.
    - “내가 마을에 가면, 비가 오지 않는다.”
    - (둘 다 부정 + 순서 바꿈 → 원래 명제와 동치) 
 
<br/>

### Converse (역), Inverse (이), Contrapositive (대우)의 필요성 

- **증명이나 추론 과정에서 활용**하기 위함

- 원래 명제: “비가 오면 길이 젖는다.” (p → q) 가 존재할 때
    - Converse (역)를 해주면, “길이 젖으면 비가 온다.”가 되고, 이 경우 물 뿌려서 길이 젖은 것일 수도 있기 때문에 반례를 찾기 쉬움
    - Inverse (이), Contrapositive (대우)를 같이 사용하며 반례를 찾기 위함임

<br/>

### Biconditional (↔) : 쌍조건문

- **Biconditional (↔)** : p와 q가 같을 때 참, 다를 때 거짓
   
    - p는 q의 필요충분조건이다.
    - p → q이고 동시에 q → p이다. 
    
- 예시
    - p = “나는 집에 있다.”
    - q = “비가 온다.”
    - p ↔ q = “나는 집에 있을 때, 그리고 오직 그때에만 비가 온다.” 

![System Resources](../../images/Discrete%20Structures%20images/biconditional.png)

<br/>

### 진리표 생성 방법 

- **진리표** : 처음부터 끝까지 계산 과정 전부를 정리해 보여주는 표

- 행(Row): 가능한 모든 경우(참/거짓 조합)를 나열.

    - 명제 개수가 n개라면 2ⁿ개의 행 필요.

- 열(Column):

    - 기본 명제(p, q …)

    - 중간 계산식 (예: ¬p, p ∨ q 등)

    - 최종 복합 명제 (보통 맨 오른쪽)

- 예시는 다음과 같다

![System Resources](../../images/Discrete%20Structures%20images/진리표예시.png)

- 예시2 : 진리표를 이용해 조건문(p → q)이 그 대우(¬q → ¬p)와 동치임을 보이려면 다음과 같이 진리표를 작성하면 된다

![System Resources](../../images/Discrete%20Structures%20images/진리표예시2.png)

- 예시3 : 진리표를 이용해 조건문의 역(converse)과 조건문의 이(inverse)가 원래 조건문과 동치가 아님을 보여라

![System Resources](../../images/Discrete%20Structures%20images/진리표예시3.png)

<br/>

### 연산자 우선순위 

![System Resources](../../images/Discrete%20Structures%20images/연산자우선순위.png)

- ex: p ∨ q → ¬r는 (p ∨ q) → ¬r와 동치이다
  
    - 만약 의도한 의미가 p ∨ (q → ¬r*라면 **반드시 괄호를 사용해야 한다**

<br/>

### Tautology (항진명제), Contradiction (모순), and Contingency (불확정명제)

- **항진명제(tautology)** : 항상 참(True)인 명제
    
    - ex : p 또는 ¬p
    - ex : 비가 오거나 비가 오지 않는다

- **모순(contradiction)** : 항상 거짓(False)인 명제

    - ex: p 그리고 ¬p
    - ex : 비가 오고, 동시에 비가 오지 않는다

- **불확정명제(contingency)** : 항상 참도 아니고, 항상 거짓도 아닌 명제

    - ex : 그냥 p 자체
    - ex : 오늘 비가 온다. → 상황에 따라 참/거짓 달라짐


![System Resources](../../images/Discrete%20Structures%20images/명제종류진리표.png)

<br/>

### Logical Equivalence (논리적 동치)

- **Logical Equivalence (논리적 동치)** : 두 복합 명제 p와 q가 항상 같은 진리값을 가지면, 즉 p ↔ q가 항진명제(항상 참)이면, p와 q는 논리적으로 동치이다

    - 이를 기호로는 **p ⇔ q** 또는 **p ≡ q**라고 쓴다

<br/>

- 주의할 점은 ⇔ 과 ↔ 은 비슷하지만 다른 개념이다

    - **Biconditional (↔)** : **특정 상황**에서 같을 수도, 다를 수도 있음
 
    - **Logical Equivalence (⇔)** : **항상** 두 식이 동일한 값을 가지므로 같은 명제
 
    - 즉, 쌍조건문(↔)에서 모든 값이 동일하면, 논리적 동치 (⇔)가 됨

아래 예시를 보자 

![System Resources](../../images/Discrete%20Structures%20images/논리적동치예시.png)

- ¬p ∨ q와 p → q는 열이 완전히 일치하기 때문에 논리적 동치이다. 
   
    - 따라서 p → q ≡ ¬p ∨ q이다

<br/>

### 드모르간 

![System Resources](../../images/Discrete%20Structures%20images/드모르간.png)

- 예시
  
    - 나는 공부와 운동 둘 다 하지는 않고 둘 중 하나만 하거나, 둘 다 안 한다 : ¬(공부 ∧ 운동)
   
    - 나는 공부를 안 하거나, 운동을 안 한다 : ¬공부 ∨ ¬운동 


<br/>

### 추가적인 연산의 기본 법칙 

- 추가적인 연산의 기본 법칙
  
    - Identity Laws (항등 법칙): 참/거짓을 붙여도 본래 값 유지

    - Domination Laws (지배 법칙): 참/거짓이 전체를 지배

    - Idempotent Laws (멱등 법칙): 같은 걸 두 번 써도 하나랑 같다

    - Double Negation Law (이중 부정 법칙): 두 번 부정하면 원래대로

    - Negation Laws (부정 법칙): p와 ¬p는 항상 참이거나 거짓
 
    - Commutative Laws (교환 법칙) : 순서 바꿔도 같다
 
    - Associative Laws (결합 법칙) : 괄호 위치를 바꿔도 결과가 같다
 
    - Distributive Laws (분배 법칙) :  AND와 OR는 곱셈/덧셈처럼 서로 분배된다
 
    - Absorption Laws (흡수 법칙) : p 또는 (p AND q)는 결국 그냥 p와 같다

![System Resources](../../images/Discrete%20Structures%20images/추가법칙.png)

<br/>

![System Resources](../../images/Discrete%20Structures%20images/추가법칙2.png)

<br/>

### 함의 변경 과정 

![System Resources](../../images/Discrete%20Structures%20images/함의변경1.png)

![System Resources](../../images/Discrete%20Structures%20images/함의변경2.png)

<br/>

### 함의 변경 과정 식 풀이 (나머지도 하나씩 해보기)

**1. p ↔ q ≡ (p ∧ q) ∨ (¬p ∧ ¬q) 증명**

- p ↔ q ≡ (p → q)∧(q → p) : 쌍조건 정의 사용

- ≡ (¬p ∨ q) ∧ (¬q ∨ p) : 조건문 변환 (p → q ≡ ¬p ∨ q)

- ≡ (¬p ∨ q) ∧ (¬q ∨ p) : **분배법칙 사용** -> 여기서 중요
    
    - 위 식을 분배법칙을 이용해서 정리하면 다음과 같다
 
    - ≡ (((¬p ∧ (¬q ∨ p)) ∨ (q ∧ (¬q ∨ p))) : 여기서 각각 한번씩 분배법칙을 또 해야함. 즉 크게 한번, 작게 2번
 
    - ≡ (¬p ∧ ¬q) ∨ (¬p ∧ p) ≡ (¬p ∧ ¬q) : 처음 분배법칙

    - ≡ (q ∧¬ q) ∨ (q ∧ p) ≡ (q ∧ p) : 두번째 분배법칙

- 최종적으로 (¬p ∨ q) ∧ (¬q ∨ p) ≡ (p ∧ q) ∨ (¬p ∧ ¬q) 증명가능 

<br/>

**2. ¬(p ∨ (¬p ∧ q)) ≡ ¬p ∧ ¬q 증명**

- ¬(p ∨ (¬p ∧ q)) ≡ ¬p ∧ ¬(¬p ∧ q) : 드모르간 법칙

- ≡ ¬p ∧ [¬(¬p) ∨ ¬q] ≡ ¬p ∧ (p ∨ ¬q) : 이중 부정 법칙

    - **여기서 중요한 점**은 드모르간으로 인해  (p ∨ ¬q) 앞에 부정(¬)이 오고 오고 분배해줄 때 **괄호를 없애면 안 됨**
 
    - 즉, ¬p ∧ [¬(¬p) ∨ ¬q] 에서 부정(¬)을 분배했을 때 ¬p ∧ p ∨ ¬q 와 같이 **괄호를 빼면 틀림**
 
    - 괄호는 정해진 순서이기 때문에 순서를 어기는 것이 됨 

- ≡ (¬p ∧ p) ∨ (¬p ∧ ¬q) : 분배 법칙

- ≡ F ∨ (¬p ∧ ¬q)

- ≡ ¬p ∧ ¬q 증명완료

<br/>

**3. (p ∧ q) → (p ∨ q)”가 항진명제(항상 참인 명제)임을 보여라**

- (p ∧ q) → (p ∨ q) ≡ ¬(p ∧ q) ∨ (p ∨ q) : 조건문의 정의

- ≡ (¬p ∨ ¬q) ∨ (p ∨ q) : 드모르간 법칙

- ≡ (¬p ∨ p) ∨ (¬q ∨ q) : 결합법칙/교환법칙

    - **우선순위가 동일한 연산자만 존재한다면, 괄호가 없어도 무방함**
 
    - 우선순위가 다를 경우에는 괄호는 제거하면 안됨 
 
- ≡ T ∨ T 이므로 증명 완료 

<br/>

### satisfiable (만족 가능), unsatisfiable (만족 불가능)

- **만족 가능 (satisfiable)**: 변수들에 참/거짓 값을 적절히 할당했을 때 전체 명제가 참이 되는 경우가 존재

    - 즉, **만족가능한 하나의 경우라도 찾으면 satisfiable함**
 
    - ex: (p∨¬q)∧(q∨¬r)∧(r∨¬p)가 satisfiable한지 판별하라
 
    - p = T, q = T, r = T로 놓으면 전체 식이 참이 된다

<br/>

- **만족 불가능 (unsatisfiable)**: 그 부정이 항상 참(항진명제)이다













