### 술어 논리(Predicate Logic)

- **술어 논리** : 변수(variable), 술어(predicate), 한정자(quantifier)를 사용하여 문장을 구성하고, 이를 통해 명제(proposition)의 참/거짓을 다룰 수 있는 논리 체계

    - 술어(predicate): 어떤 속성이나 조건을 표현하는 함수 같은 것

      - ex: P(x) : x > 0 또는 M(x) : x는사람이다

    - 변수(variable): 술어에 들어갈 대상

        - ex: x,y,z

    - 도메인(domain): 변수가 가질 수 있는 값들의 집합

        - ex: 정수 전체, 실수 전체, 학생 집합

    - 한정자(quantifier): 변수를 묶어 “모든 경우” 또는 “어떤 경우”를 표현

        - ∀x P(x): 모든 x에 대해 P(x)가 성립한다

        - ∃x P(x): 어떤 x가 존재해서 P(x)가 성립한다

<br/>

### 명제함수(Propositional function)

- **명제함수(Propositional function)** : P(x)처럼 변수를 포함한 논리 표현식

    - 단독으로는 참/거짓이 결정되지 않음 

<br/>

- **명제가 되는 조건**

    - 변수를 **도메인(domain)** 속 값으로 대체하거나, **한정자(∀, ∃)** 로 묶어주면 참/거짓이 생김

    - 도메인 값 예시: P(x) : x > 0, 도메인 U = 정수라면
 
        - P(−3): -3 > 0 → 거짓

        - P(0): 0 > 0 → 거짓

        - P(3): 3 > 0 → 참

    - 한정자 예시
        
        - ∀xP(x): “모든 x가 0보다 크다” → −1과 0 때문에 거짓
   
        - ∃xP(x): “어떤 x는 0보다 크다”→ 1이 있어서 참

<br/>

### 술어 논리 vs 명제 논리 차이 

- 명제 논리 (Propositional Logic)

    - 이미 참/거짓이 결정된 **완성된 문장**을 다룸
 
    - 예: 3은 짝수이다 (거짓)

<br/>

- 술어 논리 (Predicate Logic)

    - **조건식**과 **변수**를 사용해, 값을 넣거나 한정자를 붙여야 참/거짓이 정해지는 문장을 다룸
      
<br/>

### 명제함수(Propositional function) 예시

- 예시 1 :  R(x,y,z) : x + y = z 라고 정의하고, 도메인 U는 정수 전체

    - R(2, -1, 5): 2 + (−1) = 5 → 1 = 5 → 거짓 (F)

    - R(3, 4, 7): 3 + 4 = 7 → 참 (T)

    - R(x, 3, z): x, z에 구체적인 값이 없으므로 **참/거짓 판단 불가** → Not a Proposition

- 예시 2 : Q(x,y,z) : x − y = z 라고 정의

    - Q(2, -1, 3): 2 − (−1) = 3 → 3 = 3 → 참 (T)

    - Q(3, 4, 7): 3 − 4 = 7 → −1 = 7 → 거짓 (F)

<br/>

### 논리 연산자(∨, ∧, →, ¬)는 술어 논리에서도 사용 가능

- 명제 논리(propositional logic)의 논리 연산자(∨, ∧, →, ¬)는 **술어 논리(predicate logic)에서도 그대로 사용 가능**

    - ex: P(x) : x > 0, 도메인 = 정수
      
    - P(3) ∨ P(-1): (참 ∨ 거짓) = 참 (T)

    - P(3) ∧ P(-1): (참 ∧ 거짓) = 거짓 (F)

    - P(3) → P(-1): (참 → 거짓) = 거짓 (F)

    - P(3) → ¬P(-1): (참 → 참) = 참 (T)
 
    - 하지만 변수가 남아있는 식은 명제가 아님 → 참/거짓 판단 불가
 
        - ex: P(3) ∧ P(y)
        
        - ex: P(x) → P(y)

        - 이런 식은 **한정자(∀, ∃)** 를 붙여야만 명제가 된다

<br/>

### 한정자(quantifier)

- **∀x P(x)** : 모든 x에 대한 P(x)

- 예시

    - P(x) = “x > 0”, U = 정수 전체 → ∀x P(x) = 거짓 (음수도 있어서)

    - P(x) = “x > 0”, U = 양의 정수 → ∀x P(x) = 참

    - P(x) = “x는 짝수다”, U = 정수 전체 → ∀x P(x) = 거짓 (홀수도 있어서)

<br/>

- **∃x P(x)** : 어떤 x에 대한 P(x)

- 예시

    - P(x) = x > 0, U = 정수 전체 → ∃x P(x) = 참 (양수가 있으므로) 

    - P(x) = x < 0, U = 양의 정수 → ∃x P(x) = 거짓 (양수 중 음수는 없음)

    - P(x) = x는 짝수다, U = 정수 전체 → ∃x P(x) = 참 (짝수 존재)

<br/>

- **유한한 도메인** : ∀, ∃를 반복(loop) 검사로 생각할 수 있음

    - ∀: 전부 참이어야 참, 하나라도 거짓이면 거짓 (즉시 종료)

    - ∃: 하나라도 참이면 참 (즉시 종료), 끝까지 없으면 거짓

- **무한한 도메인** : 같은 아이디어로 생각할 수는 있지만, 실제로는 검사 과정이 끝나지 않을 수도 있다

<br/>

### 도메인에 따른 ∀와 ∃의 진리값

- ∃x P(x) (존재)와 ∀x P(x) (전칭)의 참/거짓은 **술어 P(x)** 와 **도메인 U** 에 **동시에 의존**

    - 쉽게 말해, 집합 범위가 P(x)의 식에 따라 참 거짓이 결정된다

    - 예시

    - U = 양의 정수, P(x) : x < 2

        - ∃x P(x): 참 (예: x=1이면 성립)

        - ∀x P(x): 거짓 (예: x=3이면 성립 안 함)

    - U = 음의 정수, P(x): x < 2

        - ∃x P(x): 참 (모든 음수는 2보다 작음)

        - ∀x P(x): 참 (음수 전체가 조건 만족)

    - U = {3,4,5}, P(x): x > 2

        - ∃x P(x): 참 (3, 4, 5 모두 조건 만족)

        - ∀x P(x): 참 (모두 2보다 큼)

<br/>

### 한정자의 우선순위

- **∀, ∃**는 모든 논리 연산자(∨, ∧, → 등)보다 **우선순위가 높음**

- 예

    - ∀x P(x) ∨ Q(x) = (∀x P(x)) ∨ Q(x)

    - ∀x (P(x) ∨ Q(x)) 는 **전혀 다른 의미**

    - 그런데 사람들이 종종 ∀x P(x) ∨ Q(x)를 ∀x (P(x) ∨ Q(x))처럼 **잘못 쓰곤 함**

<br/>

### 문장을 술어 논리로 옮기는 방법

- **핵심은 도메인 U를 먼저 정해야 한다**

- 예시 : Every student in this class has taken a course in Java. (이 수업에 있는 모든 학생은 Java 수업을 들었다.)

    - Solution 1: U = 이 수업에 있는 학생들

        - J(x): “x는 Java 수업을 들었다”

        - 번역: ∀x J(x)

    - Solution 2: U = 모든 사람(전체 인류)

        - S(x): “x는 이 수업의 학생이다”

        - J(x): “x는 Java 수업을 들었다”

        - 번역: ∀x (S(x) → J(x)) : 함의는 **만약 …라면 …이다**로 해석, 함의가 많이 사용되므로 **잘 기억해두기**
 
        - (잘못된 표현: ∀x (S(x) ∧ J(x))) : 전 세계 사람들이 모두 이 수업의 학생이면서 java 수업을 들어야만 참

<br/>

- 즉 여기서 핵심은

    - **∃ (존재)**: 실제로 조건을 동시에 만족하는 대상이 있어야 의미가 있으므로 **∧ 사용**
 
        - ex: 교수님이 자바 수업을 듣지 않음 -> 함의를 사용하면 전제가 F일 때 참 -> 학생 중에 자바를 듣는 학생이 없어도 참이 나옴

    - **∀ (전체)**: 모든 대상을 다루되, 학생이 아닌 사람은 조건에서 제외해야 함 **→ 사용**

        - ex: 교수님이 학생 아님 → 그런데 ∧에서는 S(x)=F면 전체가 F → 따라서 학생 아닌 사람 때문에 전체 명제가 거짓 → “모든 학생이 자바를 들었다”라는 의도가 깨짐
        
        - 함의를 사용해야 수업을 듣는 대상이 아닌 교수님은 F이므로 "참"이 되어 교수님에 의해 결과가 F가 나오지 않음   
<br/>

### 술어 논리에서의 논리적 동치(logical equivalence)

- 술어와 한정자가 들어간 문장에서도 **항상 같은 진리값을 가지면 동치** (명제논리 확장버전)

    - 즉, 어떤 술어(predicate)를 넣더라도,

    - 어떤 도메인(domain)을 사용하더라도,

    - 항상 같은 진리값을 가진다면 동치라고 한다

<br/>

### 유한 도메인에서의 한정자 전개

- **도메인이 유한(finite)** 인 경우 

    - 전칭 한정자(∀)는 **논리곱(AND, ∧)** 의 형태로 바꿀 수 있다.

    - 존재 한정자(∃)는 **논리합(OR, ∨)** 의 형태로 바꿀 수 있다.

    - 예: 도메인 U = { 1, 2, 3}

        - ∀x P(x) ≡ P(1) ∧ P(2) ∧ P(3)

        - ∃x P(x) ≡ P(1) ∨ P(2) ∨ P(3)

<br/>

- **도메인이 무한(infinite)** 인 경우

    - 이와 같은 방식으로 생각할 수는 있지만, 식이 무한히 길어져서 실제로는 **나열 불가능**

<br/>

### 한정자의 부정(Negation of Quantifiers) with 드모르간 법칙

![System Resources](../../images/Discrete%20Structures%20images/한정자부정.png)

- **핵심 : ∃와 ∀는 부정할 때 서로 바뀐다**

    - ∃의 부정 = ∀
      
    - ∀의 부정 = ∃

    - 대신 술어 P(x)는 ¬P(x)로 바뀜

<br/>

- **¬∃x P(x) ≡ ∀x ¬P(x)**

    - “P(x)인 x가 존재하지 않는다” ↔ “모든 x에 대해 P(x)가 아니다”
 
    - 즉, 어떤 x도 존재하지 않다면, 모든 x에 대해 성립하지 않음
 
    - 부정할 때 P(x) 앞에 **부정(¬)을 붙임** 

<br/>

- **¬∀x P(x) ≡ ∃x ¬P(x)**

    - “모든 x가 P(x)인 것은 아니다” ↔ “P(x)가 아닌 x가 적어도 하나 존재한다”
 
    - 즉, 모든 x에 대해서는 만족하지 않는다 = 적어도 하나의 반례가 존재한다 

<br/>

### 한정자 예시 

- ex: 이 수업에 있는 어떤 학생은 멕시코를 방문한 적이 있다

    - ∃x(S(x)∧M(x))
 
        - S(x): x는 이 수업의 학생이다

        - M(x): x는 멕시코를 방문했다

        - ∃x: 적어도 한 명의 x가 존재한다

<br/>

- ex: 이 수업의 모든 학생은 캐나다나 멕시코 중 적어도 한 곳을 방문한 적이 있다

    - ∀x(S(x)→(M(x)∨C(x)))
 
        - S(x): x는 이 수업의 학생이다

        - M(x): x는 멕시코를 방문했다

        - C(x): x는 캐나다를 방문했다 

<br/>

### Nested quantifiers (중첩 한정) 풀이 방

- 중첩된 한정자는 영어 문장의 의미나 컴퓨터 과학·수학에서 중요한 개념을 표현할 때 자주 필요

    - 한 번의 한정자로는 다 못 담아서, 여러 개(∀, ∃)를 겹쳐 써야 할 때가 많다
 
    - **ex: 모든 실수에는 역수가 있다**
 
        - ∀x∃y(x+y=0)
          
    <br/>
    
    - 위 예시 중첩된 명제 함수로도 볼 수 있다
 
        - P(x,y) : (x+y=0)
          
        - Q(x) : ∃yP(x,y) = “주어진 x에 대해, 어떤 y가 있어서 x + y = 0이 된다.”
     
        - 이때 y = −x를 잡으면 조건 만족 -> 즉, 임의의 x에 대해 항상 그에 맞는 y=−x가 존재
     
        - 따라서 Q(x)는 모든 x에서 참
     
            - 여기서 **핵심**은 모든 x에 대해 Q(x)가 성립하는지”로 **단순화**를 하고 Q(x)가 어떤 x에서도 참이므로, ∀x가 필수적이라는 걸 보여주는 것임
     
        - 증명 완료
          
    <br/>
    
    - **만약 식을 ∃y∀x(x+y=0) 이렇게 쓴다면**
 
        - ∀x(x+y=0) : “주어진 y에 대해, 모든 x+y=0을 만족해야 한다.”
 
        - ∀x는 모든 실수 x에 대해 성립해야하지만, 실제로는 오직  x=−y일 때만 조건이 참
     
        - 어떤 y를 선택해도 “모든 x”를 만족시키는 것은 불가능 -> **거짓**

<br/>

### ∀x∀y P(x,y) 와 ∀x∃y P(x,y) 풀이 방식 

- ∀x∀y P(x,y) 

    - x 하나 고르고, 모든 y 확인

    - 어떤 (x,y)라도 거짓이면 전체가 거짓 → 중단

    - 모든 (x,y)에서 참이면 전체가 참

        - 즉, **모든 쌍이 참이어야 함**

- ∀x∃y P(x,y) 

    - x 하나 고르고, y들을 차례대로 확인

    - y 중 하나라도 P(x,y)=참이면 그 x는 통과

    - 만약 어떤 x에 대해 그런 y를 못 찾으면 전체 거짓

    - 모든 x가 통과하면 전체 참.

        - 즉, **x마다 최소 하나의 y가 있어야 한다**

주의: 도메인이 무한이면 실제로 다 확인하는 건 불가능 → 이론적 의미로만 생각해야 함.

<br/>

### 순서에 따른 한정자 해석 

- P(x,y) = “x+y = y+x” 이고, 정의역 U는 실수 전체라 정의하자

    - 이때, ∀x ∀y P(x,y) 와 ∀y ∀x P(x,y) 는 같은 참 거짓 값을 가짐

- 이번엔 Q(x,y) = “x+y=0” 이고정의역 U는 실수 전체라고 정의하자

    - "모든 x에 대해, 어떤 y가 존재해서 x+y=0 이 된다"는 참

    - 하지만 “어떤 y 하나가 있어서, 모든 x에 대해 x+y=0이 된다”는 거짓
 
    - 즉 **한정자의 순서가 다르면 의미도 달라진다**

<br/>

- 예시1 : P(x,y) : x⋅y = 0, 정의역은 실수 전체

    - ∀x∀y P(x,y) → False : 모든 (x,y)에 대해 곱이 0이 되어야 하는데, 일반적으로 안 맞음

    - ∀x∃y P(x,y) → True : 모든 x마다, y=0을 잡으면 곱이 0이 되므로 참

    - ∃x∀y P(x,y) → True : x=0이면 모든 y에 대해 곱이 0 → 참

    - ∃x∃y P(x,y) → True : x=0, y=1 → 성립

<br/>

- 예시2 : P(x,y) : x/y = 1

    - ∀x∀y P(x,y) → False : 모든 x,y에 대해 x=y여야 하는데 불가능

    - ∀x∃y P(x,y) → False : 모든 x마다 y=x를 잡으면 성립하지만, y=0 문제 때문에 정의역 전체에서는 불가능

    - ∃x∀y P(x,y) → False : 고정된 x가 모든 y에 대해 x=y를 만족시킬 수 없음

    - ∃x∃y P(x,y) → True : x=2, y=2 → 2/2=1 → 참











































