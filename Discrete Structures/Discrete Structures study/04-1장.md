### 알고리즘 

- **알고리즘** : 산을 수행하거나 문제를 해결하기 위한 유한 개의 정확한 지시문

    - 즉, 알고리즘은 **끝없이 반복되지 않고**, 반드시 멈추며(유한), 모호하지 않은 **명확한** 단계로 이루어져야 함
    - 
<br/>

- **예시** : 유한한 정수의 수열에서 최댓값을 찾는 알고리즘을 설명하시오

    - (1) : 임시 최대값을 수열의 첫 번째 정수로 설정한다
 
    - (2) : 다음 정수를 임시 최대값과 비교
 
        - 만약 다음 정수가 임시 최대값보다 크면, 임시 최대값을 그 정수로 바꾼다
 
    - (4) : 수열에 정수가 더 있으면 위 단계를 반복하라. 없으면 멈춘다
 
    - (5) : 알고리즘이 끝나면, 임시 최대값은 수열에서 가장 큰 정수이다 

<br/>

 - 위 예시의 의사코드는 아래와 같다

```ruby
procedure max(a1, a2, …, an: integers)
    max := a1
    for i := 2 to n
        if max < ai then max := ai
    return max {max is the largest element}
```
<br/>

- 알고리즘은 **여러 방식으로 표현**이 가능하다. 그 단계들은 영어 문장이나 **의사코드(pseudocode)** 로 기술될 수 있다

    - **의사코드(pseudocode)** : 영어로 된 설명과 프로그래밍 언어로 작성된 코드 사이의 중간 단계이다
 
    - 의사코드는 특정 프로그래밍 언어에 의존하지 않고, 알고리즘을 사용해 문제를 푸는 데 걸리는 시간을 분석하는 데 도움을 준다

<br/>

- 알고리즘은 원하는 형태의 **모든 문제에 대해 동작**해야 한다

<br/>

### Searching Problems (탐색 문제)

- **Searching Problems (탐색 문제)** : 구별되는 원소들로 이루어진 리스트 a1, a2, …, an 안에서 특정 원소 x를 찾거나, 그 원소가 리스트 안에 없는지 판별하는 것

<br/>

- **탐색 문제 종류**

    - **선형 탐색 (Linear Search)**
 
        - 리스트의 처음부터 끝까지 차례대로 비교하며 원하는 값을 찾음
        
        - 정렬 불필요
        
        - O(n))
     
    <br/>

    - **이진 탐색 (Binary Search)**
    
        - 정렬된 리스트에서 중간값과 비교하며 범위를 절반씩 줄여 찾음
        
        - 정렬 필요
        
        - O(log n))

<br/>

-  **Linear Search Algorithm (선형 탐색 알고리즘)**

    - 리스트의 처음부터 시작하여 **원소를 하나씩 차례대로 검사**하며 원하는 항목을 찾는다
 
        - (1) : 먼저 x를 a1과 비교한다. 만약 a1에서 원하는 원소를 바로 찾았다면 위치 1을 반환
     
        - (2) : 그렇지 않다면, a2를 확인한다. 만약 x = a2라면 위치 2를 반환한다
     
        - (3) : 계속 진행하다가, 전체 리스트를 다 확인했는데도 일치하는 값이 없으면 0을 반환

<br/>

-  **Linear Search Algorithm (선형 탐색 알고리즘) 의사코드**
  
```ruby
procedure linear search(x: integer, a1, a2, …, an: distinct integers)
    i := 1
    while (i ≤ n and x ≠ ai)
        i := i + 1
    if i ≤ n then location := i
    else location := 0
    return location {location is the subscript of the term that equals x,
                     or is 0 if x is not found}
```

<br/>

### Binary Search Algorithm (이진 탐색 알고리즘)

- 입력은 오름차순으로 정렬된 리스트라고 가정한다

    - 즉, 이진 탐색은 **정렬된 리스트에서만** 사용할 수 있다 

- 이진 탐색 알고리즘은 찾고자 하는 원소를 **리스트의 중간 원소와 비교**하면서 시작한다

    - 중간값을 기준으로 크기를 비교해 **탐색 범위를 절반**으로 줄이는게 핵심

 <br/>

 - **알고리즘 과정**

    - (1) : 만약 중간 원소가 더 작다면, 탐색은 리스트의 윗부분(중간 이후)으로 진행된다
 
    - (2) : 그렇지 않다면, 탐색은 리스트의 아랫부분(중간까지 포함)으로 진행된다
 
    - (3) : 리스트 크기가 1이 될 때까지 이 과정을 반복
  
        - 찾고 있는 원소가 리스트에 있는 원소와 같다면, 그 위치를 반환
     
        - 못찾으면 찾는 원소가 없다는 뜻으로 0을 반환
        
<br/>

- **숫자 19를 찾는 예시**

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장이진탐색알고리즘19를찾는예시과정.png)

<br/>

- **이진 탐색 알고리즘 의사 코드**
  
```ruby
procedure binary search(x: integer, a1, a2,…, an: increasing integers)
    i := 1 {i is the left endpoint of interval}
    j := n {j is right endpoint of interval}
    while i < j
        m := ⌊(i + j)/2⌋
        if x > am then i := m + 1
        else j := m
    if x = ai then location := i
    else location := 0
    return location {location is the subscript i of the term ai equal to x,
                     or 0 if x is not found}
```

<br/>

### Sorting (정렬)

- 리스트의 원소들을 정렬(sort)한다는 것은 그것들을 **오름차순으로 배열**하는 것이다

<br/>

- **정렬이 중요한 이유**

    - 전체 컴퓨팅 자원의 상당 부분이 다양한 리스트를 정렬하는 데 사용된다

    - 특히, 고객, 부품 번호 등 특정 순서로 데이터를 보여줘야 하는 대규모 데이터베이스 응용에서 그렇다

<br/>

- **정렬의 종류**

    - **버블 정렬 (Bubble Sort)**

        - 아이디어: 인접한 두 원소를 비교해 잘못된 순서라면 교환, 이 과정을 여러 번 반복

        - 특징: 큰 값이 매 반복마다 거품처럼 뒤로 밀려가며 정렬됨

        - 시간 복잡도: 평균/최악 O(n²).

    - **삽입 정렬 (Insertion Sort)**

        - 아이디어: 두 번째 원소부터 시작해, 앞쪽의 정렬된 부분에 적절한 위치를 찾아 삽입.

        - 특징: 사람이 카드를 정렬하는 방식과 유사, 작은 입력에 효율적.

        - 시간 복잡도: 평균/최악 O(n²), 최선 O(n) (이미 거의 정렬된 경우).

<br/>

### 버블 정렬 (Bubble Sort) 

- 인접한 두 원소를 비교해 잘못된 순서라면 교환, 이 과정을 여러 번 반복

    - 특징: 큰 값이 매 반복마다 거품처럼 뒤로 밀려가며 정렬됨

    - 시간 복잡도: 평균/최악 O(n²)
 
<br/>

- **버블 정렬 (Bubble Sort) 예시**

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장버블정렬예시과정.png)

<br/>

- **버블 정렬 의사 코드**

```ruby
procedure bubblesort(a1,…,an : real numbers with n ≥ 2)

    for i := 1 to n − 1
        for j := 1 to n − i
            if aj > aj+1 then interchange aj and aj+1

{a1,…, an is now in increasing order}
```

<br/>

### 삽입 정렬 (Insertion sort)

- 두 번째 원소부터 시작해, 앞쪽의 정렬된 부분에 적절한 위치를 찾아 삽입

    - 특징: 사람이 카드를 정렬하는 방식과 유사, 작은 입력에 효율적
    
    - 시간 복잡도: 평균/최악 O(n²), 최선 O(n) (이미 거의 정렬된 경우)

<br/>

- **삽입 정렬 과정**

    - (1) : 두 번째 원소부터 시작한다. 두 번째 원소와 첫 번째 원소를 비교하여, 더 작으면 첫 번째 원소 앞에 삽입

    - (2) : 그다음 세 번째 원소를 앞의 세 원소 중 올바른 위치에 삽입
 
    - (3) : 이후 반복에서는 (n+1)번째 원소를 앞의 n+1개 원소 중 올바른 위치에 삽입

<br/>

- 삽입 정렬 예시

![System Resources](../../images/Discrete%20Structures%20images/04-1장삽정렬예시과정.png)

<br/>

### Big-O Notation

- f와 g가 정수나 실수 집합에서 실수 집합으로 가는 함수라고 하자. f(x)가 O(g(x))라는 말은 어떤 상수 C와 k가 존재해서 모든 x가 k보다 클 때, f(x)의 절댓값이 C배 g(x)의 절댓값보다 작거나 같음을 의미한다

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법자료사진.png)
 
    - 이를 “f(x)는 g(x)의 Big-O다” 또는 “g가 f를 점근적으로 지배한다"라고 읽는다
 
    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법함수비교사진.png)

<br/>

- **Big-O Notation 추가내용**

    - 한 쌍의 증인(C, k)을 찾으면, 무한히 많은 다른 쌍도 존재
 
    - k나 C 값을 더 크게 잡아도 부등식은 여전히 성립
 
        - 만약 C′가 C보다 크고, k′가 k보다 크다면 (C′, k′) 역시 증인이 된다
     
    - “f(x) = O(g(x))”라고 쓰는 경우도 있는데, **정확히는 f(x) is O(g(x))** 가 맞다
 
        - 하지만 이는 등호를 잘못 쓴 것이고, 실제 의미는 f와 g 사이의 부등식을 말하는 것이다
     
        - 올바른 표기는 f(x) ∈ O(g(x))이고, O(g(x))는 g(x)의 Big-O에 해당하는 함수들의 집합을 의미한다
     
        - 보통 절댓값 기호(| |)는 생략하는데, 우리가 다루는 함수들은 항상 양수 값만 가지기 때문이다

<br/>

### Big-O Notation 증명 문제 

- 다음을 증명하시오

- ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제1.png)

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제1풀이과정.png)
 
<br/>

- 다음을 증명하시오

- ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제2.png)

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제2번풀이과정.png) 

<br/>

- 다음을 증명하시오

- ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제3번.png)

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법예시문제3번풀이과정.png) 

<br/>

### Big-O Estimates for Polynomials

- **다항식(polynomial)** 은 최고차항의 차수에 따라 Big-O가 결정된다

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장빅오표기법다항식풀이과정.png) 

<br/>

### Big-O Estimates 문제 

- 중요 함수에 대한 Big-O (1)

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장주요함수에대한빅오표기법.png) 

<br/>

- 중요 함수에 대한 Big-O (2)

    - ![System Resources](../../images/Discrete%20Structures%20images/04-1장주요함수에대한빅오표기법2번째.png) 





















