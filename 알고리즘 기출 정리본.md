## 문제 1 

![image](https://github.com/user-attachments/assets/1189c35e-a07a-47ed-bd21-ca0c66bc24de)

<br/>

### 풀이과정 

### 최적 부분 구조 

![IMG_3465](https://github.com/user-attachments/assets/79f108f1-0d5f-4797-9c9d-f40320d56211)

<br/>

### DP 알고리즘 

```ruby
def max_partial_sum(a):
    n = len(a)
    if n == 0:
        return 0
    if n == 1:
        return a[0]

    Ai = [0] * n
    Ai[0] = a[0]
    Ai[1] = max(a[0], a[1])

    for i in range(2, n):
        Ai[i] = max(Ai[i-1], Ai[i-2] + a[i])

    return Ai[-1]
```

<br/>

### 의문점 : A[i-2] + A[i]가 선택되고, 다음에 A[i-1]이 선택되면 연속 조건을 위반하는가 

### 답은 위반하지 않는다. 아래 예시를 함께 보자 

![스크린샷 2025-06-09 122018](https://github.com/user-attachments/assets/b03fcaa4-533a-4eb4-a39e-1395ef9e07ed)

![스크린샷 2025-06-09 122025](https://github.com/user-attachments/assets/8d9ca562-0e53-4bc0-970a-b5d5169c1f5d)

예시에서와 같이 이전에 A[i-2] + A[i]가 선택 되더라도, 다음 단계에서 A[i-1]이 선택되면, 해당 단계인 A[i-1] 기준으로 이전 수열이 따라오는 방식이다. 따라서 A[i-2] + A[i]는 선택되지 않기 때문에 중복 문제가 발생하지 않는다

여기서 핵심은 최적 부분 구조를 만들 때, 문제에서의 조건을 말 그래도 적기만 하면 된다. 

쉽게 말해 연속성을 배제한 수열의 최대 값은 일단 max라는 함수가 필요하고, 연속성이 없기 때문에 i를 선택하거나 or i를 선택하지 않거나 를 생각하면 된다 

i를 선택하지 않는다면, i-1이 선택이 될 것이고 (by 연속성 조건), i가 선택 되면다면, i와 i-2가 선택이 될 것이다 

<br/>

## 문제 2

![image](https://github.com/user-attachments/assets/16ef4bde-595a-4034-9f5f-0739b624f716)

### 풀이 과정 

각각의 가중치의 값을 오름차순으로 정렬한 것은 다음과 같다 

- (1,4) - 1

- (1,2) - 2

- (2,3) - 3

- (1,5) - 4

- (3,4) - 5

- (2,6) - 7S

- (3,6) - 8

- (4,5) - 9

![image](https://github.com/user-attachments/assets/c09f7c54-27ae-4275-a90f-7abf8878b1ed)

![IMG_3467](https://github.com/user-attachments/assets/3d0dbd9e-9296-487a-9e4e-cb6c92a80b04)























































































