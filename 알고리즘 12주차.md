## 강연결 요소 (Strongly connected component = SCC)

유향 그래프의 **모든 정점 쌍에 대해서 양방향으로 경로가 존재**하면 **강하게 연결**되었다고 함

**강연결 요소** : 그래프 전체 대신 강하게 연결된 부분 그래프를 의미

<br/>

```ruby
 stronglyConnectedComponent(G) 
{ 
1. 그래프 G에 대해 DFS를 수행하여 각 정점 v의 완료시간 f [v]를 계산한다

2. G의 모든 간선들의 방향을 뒤집는다

3. DFS(그래프 G의 간선 역방향)를 수행하되 시작점을 1번에서 구한 f[v]가 가장 큰 정점으로 잡는다

4. 3과정에서에서 만들어진 분리된 트리들 각각을 강연결요소로 리턴한다

}
```

<br/>

## 강연결 요소 과정 

![IMG_3262](https://github.com/user-attachments/assets/33fcb0f3-2bbc-4940-8310-98eb5be1136b)

![IMG_3261](https://github.com/user-attachments/assets/b94c61de-d3a4-423c-8ad5-7d65d36d15e7)

종료시간이 빠르다 : 그 노드가 탐색에서 가장 깊이 들어가 있지 않았다, 즉 **이어지는 노드가 많이 없다**

종료시간이 느리다 : 그 노드가 탐색에서 가장 깊이 들어가 있다. 즉, **이어지는 노드가 많다**

<br/>

## 강연결 요소에서 역을 수행하는 이유

**역방향 탐색 수행 이유** : 일반적인 **DFS로는 발견할 수 없는 강연결 요소(SCC)를 정확히 찾기** 위함이다

일반적인 DFS는 출발 지점에서 갈 수 있는 모든 경로를 탐색한다

하지만, 역방향 경로를 고려하지 않기 때문에, 실제로 **서로 강하게 연결된 정점들을 놓칠 수 있다**

예를 들어, A → B → C가 있지만, C에서 A로 돌아오는 경로가 있는지 알 수 없다

비유를 하자면, 높은 산에서 떨어지는 물이 아래에 도착하는 관계를 보면 우리는 위에서 아래로만 관계를 알 수 있지만 강연결 요소를 사용하면 아래에서 위로 올라가는 관계를 파악할 수 있다 

<br/>

## 강연결 요소 특징 

강연결 요소는 **유향 그래프(Directed Graph)** 에서 서로 강하게 연결된 노드들의 집합을 찾는다

- SCC에 속한 노드들은 어떤 방향으로도 왕복이 가능하다는 특징이 존재

- 예를 들어, A → B → C → A가 있다면, 이들은 서로 왕복이 가능하므로 같은 SCC에 속함

이 알고리즘을 이용하면 실제로 우리가 웹 페이지 간의 하이퍼링크가 상호 연결된 구조를 분석할 때, SCC로 묶어서 서로 접근 가능한 그룹을 찾을 수 있다 

<br/>

## 최단 경로(중요)

**최단 경로 문제** : 그래프에서 두 정점 사이의 경로 중에서 가중치 합이 가장 작은 경로를 찾는 문제를 말한다 

무향 그래프는 양쪽 방향으로 간선이 다 있다고 볼 수도 있음

최단 경로 문제는 **단일 시작점**에서 할 것인지, **모든 정점 쌍**에서 할 것인지에 따라 분류할 수 있다

<br/>

**1. 단일 시작점 최단 경로 문제**

- 음의 가중치를 허용하지 않는 경우 (**0이상의 양수**) -> **다익스트라 알고리즘**

- 음의 가중치를 **허용하는 경우** -> **벨만-포드 알고리즘**

- **싸이클이 없는** 그래프의 경우

단, 음의 가중치를 허용한다고해서 **싸이클에서의 가중치 합이 음이 되면 안 된다**

이렇게 되면 그러면 해당 사이클을 반복하여 특정 경로의 가중치 합을 음의 무한대로 보낼 수 있기 때문이다 

ex: A → B → C → A라는 사이클의 가중치가 -3이라면, 이 경로를 반복하면 계속 값이 작아지기 때문에 최단 경로를 정의할 수 없음

<br>

**2. 모든 정점 쌍에 대한 최단 경로 문제** 

이 경우는 **플로이드-워샬 알고리즘**을 사용한다 

## 다익스트라 알고리즘

다익스트라 알고리즘은 **모든 간선의 가중치는 음이 아니여야 한다는 것이 특징**이다

**시간복잡도 : O(|E|log|V|)**

```ruby
Dijkstra(G, r)                       // G: 그래프 (V, E), r: 시작 정점
▷ G = (V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
    S ← ∅ ;                          // S: 최단 거리가 확정된 정점들의 집합 (초기에는 공집합)

    for each u ∈ V                   // 그래프의 모든 정점 u에 대해
        d[u] ← ∞ ;                   // d[u]: 시작점 r에서 u까지의 최단 거리 추정값 (초기에는 무한대)
    d[r] ← 0 ;                       // 시작 정점 r의 거리는 0으로 설정

    while (S ≠ V) {                  // 모든 정점의 최단 거리가 확정될 때까지 반복
        u ← extractMin(V - S, d) ;   // S에 포함되지 않은 정점들 중에서 d값이 가장 작은 정점 u 선택
        S ← S ∪ {u} ;                // u의 최단 거리를 확정하고 S에 추가

        for each v ∈ L(u)            // u와 인접한 정점 v에 대해 반복
            if (v ∈ V-S and d[u] + w[u, v] < d[v]) then {   // u를 통해 v로 가는 경로가 더 짧다면
                d[v] ← d[u] + w[u, v] ;                   // d[v]를 더 짧은 거리로 갱신 (이완)
                prev[v] ← u ;                             // prev[v]에 u 저장 → 경로 추적을 위함
            }
    }
}


extractMin(Q, d[])
{
    집합 Q에서 d값이 가장 작은 정점 u를 리턴한다 ;
}
```

위 코드에서 v ∈ V-S and d[u] + w[u, v] < d[v] 단계는 V-S 집합의 노드중에서 시작점에서 해당 노드로 접근하는 것보다 u를 거쳐서 더 많은 경로를 추가했음에도 해당 노드에 도달한 거리가 더 짧다면 그 값을 최단 경로 비용으로 지정하자는 것이다 

또한 위 코드는 prev[v]로 더 짧은 경로를 저장만 해두고 따로 return은 하지 않았다

<br/>

## 다익스트라 알고리즘 예시 

![IMG_3265](https://github.com/user-attachments/assets/a0f87912-b3df-4988-8fb1-15bd7e603d0f)

![IMG_3266](https://github.com/user-attachments/assets/e17f6122-f350-43da-a516-bd1dfaffbb43)

<br/>

## 잘못된 예시 

![image](https://github.com/user-attachments/assets/b00a466b-4a51-4820-b997-b7bf43c5c275)




















































































