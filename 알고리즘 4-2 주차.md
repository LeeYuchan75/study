## Radix sort(기수 정렬)

기수 정렬 : 최대 k까지의 자릿수를 갖는 원소들을 정렬할 때 사용할 수 있는 O(n) 정렬의 일종

이때 k는 상수여야 n이 증가해도 Θ(k⋅n) = Θ(n)을 유지함 

<br/>

**기수 정렬 특징** 

1. 자릿수를 기준으로 정렬함(일의자리 부터 ~ k의 자리까지)

2. 기수 정렬은 stable sort이다

<br/>

**기수 정렬 과정**

![radix_sort_combined](https://github.com/user-attachments/assets/cb35f970-c3fc-4b04-8410-d280d879e11a)

4번째 과정의 정렬를 보면 2154 가 0004보다 더 위에 있기 때문에(=index가 더 먼저이기 때문에) 순서가 유지됨(4:[2154,0004]) -> **stable**

<br/>

## 기수 정렬 예시 코드 

```ruby
def radix_sort(nums):
    RADIX = 10
    placement = 1
    max_digit = max(nums)

    while placement < max_digit:
        buckets = [list() for _ in range(RADIX)]
        for i in nums:
            tmp = int((i / placement) % RADIX)
            buckets[tmp].append(i)

        a = 0
        for b in range(RADIX):
            buck = buckets[b]
            for i in buck:
                nums[a] = i
                a += 1

        placement *= RADIX

    return nums
```

<br/>

## 코드 내용 요약

## List Comprehension

**정의 : [표현식 for 변수 in 반복가능한_객체]**

예시 코드 

```ruby
예시 코드 1 
squares = [x**2 for x in range(10)]
print(squares)

결과 : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


예시 코드 2
evens = [x for x in range(10) if x % 2 == 0]
print(evens)

결과 : [0, 2, 4, 6, 8]


예시 코드 3
pairs = [(x, y) for x in range(3) for y in range(2)]
print(pairs)

결과 : [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]
```

기수 정렬 예시에서 **buckets = [list() for _ in range(RADIX)] 이 코드는 RADIX 만큼 반복하여 빈 리스트를 만들라는 의미이다**

즉 buckets는 [[], [], [], [], [], [], [], [], [], []] -> 빈 리스트 10개를 요소로 갖는 리스트를 생성 (_는 관례적으로 사용하지 않는 값으로 표현)

<br/>

##  tmp = int((i / placement) % RADIX)

기수 정렬 코드에서 이 부분이 핵심이다 

i는 nums으로 입력 받은 값을 순서대로 가져오고, placement와 radix를 이용해서 원하는 자릿수를 구하는 형식이다 

예를 들어 우리는 4567 = 4x1000 + 5x100 + 6x10 + 7x1 로  자릿수를 표현할 수 있지만, 컴퓨터는 **10으로 나눈 나머지는 항상 1의 자리 숫자** 임을 이용하여 아래와 같이 자릿수를 구한다

<br/>

10의 자리(placement = 10) -> (4567 / 10) % 10 → 456.7 % 10 → 6.7 → int(6) 같이 placement로 소수점을 이용하여 추출하고자 하는 자릿수를 정수 부분의 일의 자리로 만들고, RADIX(=10)로 나눠 나머지(=우리가 원하는 자릿수의 값)을 구한다

만약 2진수로 표현된 숫자라면, %2를 해서 자릿수를 구해야한다

<br/>

수학적으로 접근해보면, 나누기는 빼기의 전체 횟수와 같다. 10진수 기준으로 한 자릿수는 0~9 까지 10이 가득차야 다음 단계로 넘어가는 것처럼 

가장 위에서부터 10을 계속 빼내어 나온 나머지를 이용한 원리이다

<br/>

## buck = buckets[b]

위 코드에서 buckets이 리스트 형태 이므로 buck의 타입도 리스트가 됨 

이후 0번째 부터 차례대로 대입함 

















































































































