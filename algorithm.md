## 알고리즘 

알고리즘 : 어떤 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어내는 과정을 체계적으로 기술한 것을 말함

알고리즘의 분석은 정확성 분석과 효율성 분석이 있음 

1. 정확성(correctness) 분석 : 알고리즘이 주어진 문제의 요건을 만족하는지 분석하는 것을 의미함

2. 효율성(efficiency) 분석 :알고리즘이 얼마나 자원을 효율적으로 사용하는지 분석하는 것을 의미함 (ex: 시간, 메모리, 통신대역 등)

<br/>

## 알고리즘 수행 시간 예시 1

```ruby
sample1(A[ ], n) 
{ 
    k = [n/2] ;
    return A[k];
}
```
        
<br/>

## 시간 복잡도 계산 

1. 입력 받기: 배열 A와 n을 입력받는 단계이다. 입력 크기 n에 비례하는 시간복잡도를 가진다. 즉, **O(1)** 이다

2. k 계산: k는 n / 2의 몫을 구하는 연산이고, 이 연산도 **O(1)** 이다. 단순한 나눗셈과 내림 연산이므로 상수 시간이 걸린다.  

3. 배열 A에서 k 번째 요소 반환: **A[k]** 로 배열에서 특정 인덱스의 요소를 반환하는 연산이고
배열에서 인덱스를 참조하는 연산은 **O(1)** 이다

<br/>

## 만약 O(1)이 수없이 많다면 ? 

2가지 경우가 있는데 첫 번째 경우는 O(1)이 수없이 많은 것과 O(1)을 n번 반복하는 경우가 있음

<br>

## 전자의 경우 

```ruby
void exampleFunction() {
    int a = 10;   // O(1)
    int b = 20;   // O(1)
    int c = a + b; // O(1)
    int d = c * 2; // O(1)
    cout << d;     // O(1)
}
```

위 코드는 연산 개수가 고정되어 있고, 입력 크기 n과 무관함 (해당 코드에 n에 따라 바뀌지 않음) -> 이러한 경우 O(1)이다

<br/>

## 후자의 경우 

```ruby
void exampleFunction(int n) {
    for (int i = 0; i < n; i++) { 
        cout << "Hello";  // O(1)
    }
}
```

여기서는 O(1) 연산을 n번 반복하고 있음. 즉, 입력 크기 n에 따라 실행 횟수가 변함 → O(n)

<br/>

## 알고리즘 수행 시간 예시 2

```ruby
sample2(A[ ], n) 
{ 
    sum ← 0 ; 
    for i ← 1 to n
        sum← sum+ A[i] ;
    return sum ;
 }
```

<br/>

이 알고리즘의 시간 복잡도를 분석해보면, 먼저 sum ← 0; 연산은 한 번만 수행되므로 **O(1)** 의 상수 시간이 소요된다.

그다음 for i ← 1 to n 반복문이 등장하는데, 이는 n번 반복되며, 반복문 내부에서 sum ← sum + A[i]; 연산이 매번 실행된다. 이 연산 자체는 **O(1)** 이지만, 반복문이 n번 실행되므로 전체 반복문에서 수행되는 연산의 총 시간 복잡도는 **O(n)** 이 된다

마지막으로 return sum; 문장은 단순한 반환 연산으로, 한 번만 실행되므로 **O(1)** 의 상수 시간이 걸린다.

이제 모든 연산의 시간 복잡도를 합산하면, **O(1) + O(n) + O(1) = O(n)** 이므로 최종적으로 이 알고리즘의 **시간 복잡도는 O(n)** 이다.


























































