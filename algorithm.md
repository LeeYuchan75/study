## 알고리즘 

알고리즘 : 어떤 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어내는 과정을 체계적으로 기술한 것을 말함

알고리즘의 분석은 정확성 분석과 효율성 분석이 있음 

1. 정확성(correctness) 분석 : 알고리즘이 주어진 문제의 요건을 만족하는지 분석하는 것을 의미함

2. 효율성(efficiency) 분석 :알고리즘이 얼마나 자원을 효율적으로 사용하는지 분석하는 것을 의미함 (ex: 시간, 메모리, 통신대역 등)

<br/>

## 알고리즘 수행 시간 예시 1

```ruby
sample1(A[ ], n) 
{ 
    k = [n/2] ;
    return A[k];
}
```
        
<br/>

## 시간 복잡도 계산 

1. 입력 받기: 배열 A와 n을 입력받는 단계이다. 입력 크기 n에 비례하는 시간복잡도를 가진다. 즉, **O(1)** 이다

2. k 계산: k는 n / 2의 몫을 구하는 연산이고, 이 연산도 **O(1)** 이다. 단순한 나눗셈과 내림 연산이므로 상수 시간이 걸린다.  

3. 배열 A에서 k 번째 요소 반환: **A[k]** 로 배열에서 특정 인덱스의 요소를 반환하는 연산이고
배열에서 인덱스를 참조하는 연산은 **O(1)** 이다

<br/>

시간 복잡도를 계산하는 방법은 각 코드의 시간 복잡도에서 가장 큰 시간 복잡도를 택해주면 된다

예를 들어 함수 안에 첫번째 코드의 시간 복잡도가 O(n)이고 다음 코드의 시간 복잡도가 O(n2) 이라먼 총 시간 복잡도는 O(n2)이다 

또한, 시간 복잡도를 비교할 때는 상수 계수(Constant Factor)는 무시하고, 가장 빠르게 증가하는 항만 고려해야 하기 때문에 O(2n)과 O(n) 은 둘 다 O(n)으로 같음 (시간 복잡도는 입력이 매우 커질 때(n → ∞) 실행 시간이 **어떻게 변하는지**를 보는 것이기 때문이다)

<br/>

## 만약 O(1)이 수없이 많다면 ? 

2가지 경우가 있는데 첫 번째 경우는 O(1)이 수없이 많은 것과 O(1)을 n번 반복하는 경우가 있음

<br>

## 전자의 경우 

```ruby
void exampleFunction() {
    int a = 10;   // O(1)
    int b = 20;   // O(1)
    int c = a + b; // O(1)
    int d = c * 2; // O(1)
    cout << d;     // O(1)
}
```

위 코드는 연산 개수가 고정되어 있고, 입력 크기 n과 무관함 (해당 코드에 n에 따라 바뀌지 않음) -> 이러한 경우 O(1)이다

<br/>

## 후자의 경우 

```ruby
void exampleFunction(int n) {
    for (int i = 0; i < n; i++) { 
        cout << "Hello";  // O(1)
    }
}
```

여기서는 O(1) 연산을 n번 반복하고 있음. 즉, 입력 크기 n에 따라 실행 횟수가 변함 → O(n)

<br/>

## 알고리즘 수행 시간 예시 2

```ruby
sample2(A[ ], n) 
{ 
    sum ← 0 ; 
    for i ← 1 to n
        sum← sum+ A[i] ;
    return sum ;
 }
```

<br/>

이 알고리즘의 시간 복잡도를 분석해보면, 먼저 sum ← 0; 연산은 한 번만 수행되므로 **O(1)** 의 상수 시간이 소요된다.

그다음 for i ← 1 to n 반복문이 등장하는데, 이는 n번 반복되며, 반복문 내부에서 sum ← sum + A[i]; 연산이 매번 실행된다. 이 연산 자체는 **O(1)** 이지만, 반복문이 n번 실행되므로 전체 반복문에서 수행되는 연산의 총 시간 복잡도는 **O(n)** 이 된다

마지막으로 return sum; 문장은 단순한 반환 연산으로, 한 번만 실행되므로 **O(1)** 의 상수 시간이 걸린다.

이제 모든 연산의 시간 복잡도를 합산하면, **O(1) + O(n) + O(1) = O(n)** 이므로 최종적으로 이 알고리즘의 **시간 복잡도는 O(n)** 이다.

<br/>

## 예시 알고리즘 3

```ruby
sample3(A[ ], n) 
{ 
    sum ← 0 ; 
    for i ← 1 to n
       for j ← 1 to n
          sum ← summ+ A[i]*A[j] ; 
    return sum ;
}
```

이 알고리즘에서 sum ← 0;과 return sum;은 각각 한 번만 실행되므로 **O(1)** 이다.

하지만 for i ← 1 to n과 for j ← 1 to n 두 개의 반복문이 중첩되어 있어, 내부 연산 sum ← sum + A[i] * A[j];는 n × n = n²번 실행된다

따라서 전체 시간 복잡도는 **O(n²)** 이며, 입력 크기 n이 증가할수록 실행 시간은 n의 제곱에 비례하여 증가하는 알고리즘이다

<br/>

## 알고리즘 수행 시간 예시 4

```ruby
sample4(A[ ], n) 
{ 
  sum ← 0 ; 
  for i ← 1 to n
     for j ← 1 to n { 
        k ← A[1 ... n]에서 임의로 [n/2] 개를 뽑을 때 이들 중 최댓값;        
        sum ← sum + k ; 
     }
  return sum 
}
```

1. sum ← 0; → sum을 0으로 초기화 **O(1)**

2. 이중 반복문(for i와 for j) : i가 1부터 n까지 반복 (n번 반복), j가 1부터 n까지 반복 (n번 반복)즉, 내부 코드가 총 **n × n = O(n²)** 번 실행됨

3. k의 값 계산 : 배열 A[1 ... n]에서 n/2개의 원소를 무작위로 선택 후, 그중 최댓값을 찾음 배열에서 최댓값을 찾는 연산은 일반적으로 **O(n)**

4. sum ← sum + k; 수행 : 내부에서 k를 구하는 과정이 **O(n)** 이므로 O(n²)번 실행될 때마다 내부 연산이 **O(n)** 이 걸림 즉, 최종적으로 **O(n³)** 이 됨

5. return sum; → 결과 반환 **O(1)**

**최종 시간 복잡도는 O(n3)이다**

<br/>

## 알고리즘 수행 시간 예시 5

```ruby
factorial(n) 
{ 
    if (n=1) return 1 ; 
    return n*factorial(n-1) ;
}
```

함수는 n번의 재귀 호출을 하며, 각 호출에서 **O(1)** 의 연산(곱셈)을 수행하므로, 전체 시간 복잡도는 **O(n)** 이다 

<br/>

## 점근적 표기법 
 
**점근적 표기법이란 알고리즘의 성능을 입력 크기(n)가 커질수록 어떻게 변하는지 나타내는 방법이다**

주로 시간 복잡도와 공간 복잡도를 나타낼 때 사용되고, 이를 통해 알고리즘이 얼마나 효율적인지, 특히 입력 크기가 매우 커졌을 때 어떤 성능을 보이는지 예측할 수 있다


![Image](https://github.com/user-attachments/assets/9edfa3f9-f80a-484c-834f-aed237160c24)


실제 기업에서는 nlogn까지 사용하고, 이 이상은 대용량 데이터가 들어가면 너무 커져서 nlogn 이하의 시간복잡도를 가지도록 알고리즘을 만들고 있음 

<br/>

## Big O notation

O(g(n)) : 알고리즘이 최악의 경우에 실행되는 시간(또는 공간)이 **g(n)** 보다 크지 않음을 나타내는 것 

<br/>

## formal definition

O(n) = { f(n) | ∃c > 0, n0 ≥ 0 s.t. ∀n ≥ n0, cg(n) ≥ f(n) } (∃c : 어떤 c와 n0가 존재한다. ∀n : 모든 n에 대해, s.t. : such that -> ~ 일때, 따라서 라는 의미)

해석하면, **"어떤 c > 0과 n0 ≥ 0이 존재하여, 모든 n이 n0 이상일 때 cg(n) ≥ f(n)을 만족한다"** 는 의미이고, 즉  조건을 만족하는 **c와 n0가 하나라도 존재하면** **f(n) = O(g(n))** 이 성립한다고 할 수 있다.

<br/>

## 예시 : f(n) = n² + 3n

f(n) = n² + 3n이 **O(n²)** 에 속하는지 확인하고자 함

g(n) = n² 이라 하고, f(n) = n² + 3n이 **O(n²)** 에 속하려면, **f(n)** 가 n²보다 더 빠르게 증가하지 않아야 한다.

조건: ∃c > 0, n0 ≥ 0: 상수 c = 2를 선택할 수 있다. (조건에 맞는 c를 하나라도 찾으면 참)

∀n ≥ n0, cn² ≥ f(n): 모든 n ≥ 1에 대해, 2n² ≥ n² + 3n이 성립하는지 확인

예를 들어, n = 2일 때, 2(2)² = 8이고, 2² + 3(2) = 4 + 6 = 10이므로 8 ≥ 10은 성립하지 않지만, 큰 값의 n에서 성립한다. **작은 값에서 성립을 안 하더라도 나중에 무수히 커졌을 때가 크다면 성립함**

따라서, f(n) = n² + 3n은 **O(n²)** 에 속한다 

<br/>

## Big O Relation 증명 예시 

여기서 Big O Notation 과 Big O Relation 의 정의는 다음과 같다

Big O Notation : 단일 함수의 점근적 성장 속도를 표현

Big O Relation : 여러 함수 간의 Big-O 관계를 나타냄

<br/>

다음을 증명하고자 한다

## f1(x) = O(g1(x)), f2(x) = O(g2(x)) 이면, (f1 + f2)(x) = O(max(|g1(x)|, |g2(x)|))

<br/>

## 1. Big-O 정의 복습

함수 f(x) 가 O(g(x)) 라는 것은, 어떤 양수 상수 C 와 x0 가 존재하여 모든 x ≥ x0 에 대해

|f(x)| ≤ C |g(x)| 가 성립한다는 뜻이다.

즉, f1(x) = O(g1(x)) 와 f2(x) = O(g2(x)) 라는 것은 다음을 만족하는 상수 C1, C2 및 임계점 x1, x2 가 존재한다는 뜻이다.

|f1(x)| ≤ C1 |g1(x)|, ∀ x ≥ x1

|f2(x)| ≤ C2 |g2(x)|, ∀ x ≥ x2

<br/>

## 2. 두 함수의 합에 대한 상한 찾기

이제 f1(x) + f2(x) 를 살펴보자.

|f1(x) + f2(x)| ≤ |f1(x)| + |f2(x)| (by 삼각 부등식)

위에서의 Big-O 정의를 대입하면,

|f1(x) + f2(x)| ≤ C1 |g1(x)| + C2 |g2(x)|

<br/>

## 3. 최대값을 이용한 상한 표현

우리는 max(|g1(x)|, |g2(x)|) 을 상한으로 표현하고 싶고, 다음 부등식을 이용할 수 있다.

|g1(x)| ≤ max(|g1(x)|, |g2(x)|), |g2(x)| ≤ max(|g1(x)|, |g2(x)|)

따라서, C1 |g1(x)| + C2 |g2(x)| ≤ (C1 + C2) max(|g1(x)|, |g2(x)|)

즉, |f1(x) + f2(x)| ≤ (C1 + C2) max(|g1(x)|, |g2(x)|) 이므로, C = C1 + C2 로 설정하면,

f1(x) + f2(x) = O(max(|g1(x)|, |g2(x)|)) 가 성립한다.






















































