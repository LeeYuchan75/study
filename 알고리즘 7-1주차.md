## 상호 배타적 집합

상호 배타적 집합 : 서로 원소를 공유하지 않는 여러 집합들의 모임. (ex: {1, 2}, {3, 4}, {5}는 상호 배타적(disjoint) 집합이다}

각 집합은 **대표 원소**로써 해당 집합을 표현한다 (ex: {1, 2, 3} 집합의 대표 원소를 1로 하면, 1을 통해 이 집합을 식별할 수 있음)

<br/>

## 관련 연산 

**1. Make-Set(x)**

- 노드 x를 생성하고 대표 노드를 자기 자신으로 설정

- 자기 자신을 가리키는 포인터를 저장함

- 연결 리스트의 끝(next)은 NIL로 설정

<br/>

**2. Find-Set(x)**

- 노드 x의 대표 노드에 대한 포인터를 반환함

- 모든 노드가 대표를 가리키고 있기 때문에 빠름 (O(1))

<br/>

**3. Union(x, y)**

- x와 y가 속한 리스트를 병합

- 일반적으로 x의 리스트 뒤에 y의 리스트를 붙임

- 이때, y 쪽 리스트의 모든 노드의 대표 포인터를 x의 대표로 업데이트를 해야하는데 **이 작업이 비효율의 원인**
 
<br>

## 간단한 예시 

```ruby
## 각 원소 생성 -> 초기 상태는 각각의 집합으로 이루어짐 
Make-Set(1)
Make-Set(2)
Make-Set(3)
Make-Set(4)
Make-Set(5)

## 위 코드 결과
1    2    3    4    5


## 만약 1과 2를 병합하고 싶다면 아래와 같이 코드를 작성하면 됨
Union(1, 2)
```

![image](https://github.com/user-attachments/assets/f5679495-09d6-464a-b869-2418e1e82298)

<br/>

## 상호 배타적 집합 알고리즘 

```ruby
CONNECTED-COMPONENTS(G)
for each vertex v ∈ G.V
    MAKE-SET(v)
for each edge (u, v) ∈ G.E
    if FIND-SET(u) ≠ FIND-SET(v)
        UNION(u, v)

SAME-COMPONENT(u, v)
if FIND-SET(u) == FIND-SET(v)
    return TRUE
else return FALSE
```

- G는 그래프(Graph) 전체를 의미

- V는 그래프 G의 정점(Vertex)의 집합 (ex: 정점이 a, b, c, ..., j 라면 V = {a, b, c, ..., j})

- E는 그래프 G의 간선(Edge)의 집합 (ex: 간선이 {(a, b), (b, c), (e, f)} 등이라면 E = {(a, b), (b, c), (e, f)})

위 코드에서 G.V는 그래프의 정점을 의미

또한, if FIND-SET(u) ≠ FIND-SET(v) 이 구문에서는 각각 간선을 비교하여 연결되어 있는지 확인하는 조건문이다 

<br/>

## 시간복잡도 문제 

일반적으로 Union(x, y)의 과정은 다음과 같다 

![image](https://github.com/user-attachments/assets/1496e073-520c-41cf-aaf4-1d399dee7bd5)

첫번째 집합의 tail를 두번째 집합의 가장 앞 원소에게 지정하고, 두번째 원소의 모든 요소가 첫번째 원소의 대표 원소에게 포인터를 지정해야한다 

이 과정의 최악의 경우는 아래와 같이 O(n²)만큼 소요된다 

![image](https://github.com/user-attachments/assets/5ea6bcd2-50dd-4407-b0c6-5ebdc0b4dfd3)

위 알고리즘을 보면 n개의 원소를 Make-set()를 실행해도, 시간복잡도는 O(1)를 n번 한 것이므로 괜찮지만 

이후 union의 과정은 다음과 같이 O(n²)만큼 소요된다

1. Union(x2,x1) : x1이 x2에게 대표 원소 ... 1회 업데이트

2. Union(x3,x2) : x1과 x2가 x3에게 대표 원소 ... 2회 업데이트 

3. Union(x4,x3) : x1과 x2가 x가 x4에게 대표 원소 ... 3회 업데이트 

위 과정을 반복하면, 1 + 2 + .. + (n-1) 이고 시그마 공식을 사용하면 1/2(n²+n)만큼 소요 되어 빅 오 표기법으로 계산하면 O(n²)가 된다 

























































































