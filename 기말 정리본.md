## 8-1주차 

### 8주차 흐름 순서 

동적 프로그래밍의 개요 및 강의에서 다룰 주제

피보나치 수열

행렬 경로 문제

돌 놓기 문제

<br/>

### 동적 프로그래밍

**동적 프로그래밍** : 문제의 해답에 **더 작은 문제의 해답**이 포함되어 있으며, 이를 **재귀호출로 구현할 때 같은 해답을 구하기 위한 중복 호출**이 다수 발생하는 경우에 활용하는 **문제해결 기법**

<br/>

### 동적 프로그래밍 목적 

재귀를 사용했을 때 **같은 연산을 반복해야하는 비효율적인 연산을 해결**하기 위해 계산된 값을 **메모리에 저장**하여 효율적으로 계산하기 위함

<br/>

### 동적 프로그래밍을 적용하는 문제의 두 가지 성질

- **최적 부분 구조** : **큰 문제의 최적 솔루션에 작은 문제의 최적 솔루션이 포함**, 즉 하위 레벨로 갔을 때 해답이 존재해야 함 -> base case만 알고 있으면 안되고, **모든 하위 단계를 구할 수 있어야 함**

- **중복되는 부분 문제** : 재귀적 해법으로 풀면 같은 문제에 대한 **재귀호출이 심하게 중복되는 문제**

<br/>

### 피보나치 예시

![image](https://github.com/user-attachments/assets/5b8af235-fc63-454e-90de-3b32b803d994)

<br/>

### 피보나치 & 동적 프로그래밍

![image](https://github.com/user-attachments/assets/24408eed-5592-4730-870e-2a4a743e28c0)

<br/>

### 행렬 경로 문제

![image](https://github.com/user-attachments/assets/1a96ffb7-ea46-4ed0-ab49-a12945da1060)

**목표** : 행렬의 좌상단에서 시작하여 우하단까지 이동하되, 방문한 칸에 있는 수들을 더한 값이 **최대화**되도록 한다

<br/>

### 행렬 경로 문제 최적 부분 구조 

**시간 복잡도 : O(2^(n+m))** (n x m 행렬)

![image](https://github.com/user-attachments/assets/17a0d789-e040-4240-baff-a9533ceb1c9c)

- m[i][j] : 행렬의 각 칸에 있는 숫자

- c[i][j] : (1,1)에서 시작해서 (i,j)에 도달할 수 있는 최대 점수

- 점수는 이동 경로 중 방문한 칸의 수를 누적해서 계산함

<br/>

### 행렬 경로 문제 & DP

**시간 복잡도 : Θ(𝑛2)**

```ruby
matrixPath(n) 
▷(n, n)에 이르는 최고점수 
{ 

for i ← 0 to n
    c[i, 0] ← 0; 

for j ← 1 to n
    c[0, j] ← 0; 

for i ← 1 to n
    for j ← 1 to n
       c[i, j] ← mij + max(c[i-1,  j], c[i,  j-1]);     ▷ mij의 데이터만 주어지고 C는 모든 위치까지의 최대 경로가 저장됨

return c[n, n]; 
}
```

![IMG_3154](https://github.com/user-attachments/assets/597139cf-2094-4810-8f7b-c986807dc827)

<br/>

### 돌 놓기 문제

돌 놓기 문제는 3 × 𝑛 행렬의 각 칸에 양 또는 음의 정수가 기록되어 있으며, 해당 행렬에 돌을 놓는 상황이다

**제약조건**

- 가로나 세로로 인접한 두 칸에 동시에 조약돌을 놓을 수 없다

- 각 열에는 적어도 하나 이상의 조약돌을 놓는다

**목표**: 돌이 놓인 자리에 있는 수들의 합이 최대가 되도록 돌 놓기

<br/>

![image](https://github.com/user-attachments/assets/544b23da-bd9d-42fa-927f-c45011eea3ed)

![image](https://github.com/user-attachments/assets/65121e32-3250-4bfb-9e7e-d1d35350c578)

<br/>

### 돌 놓기 문제 최적 부분 구조 확인

![image](https://github.com/user-attachments/assets/db6ff4d9-5937-4e29-9462-edaa268a746c)

<br/>

### 돌 놓기 문제 재귀 알고리즘

```ruby
pebble(i, p)
▷i열이 패턴 p로 놓일 때의 i열까지의 최대 점수 합 구하기
▷w[i, p] : i 열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수 합  p = {1, 2, 3, 4}
{
    if (i == 1)
        return w[1, p];
    else {
        max ← -∞;  ▷ 초기 max값을 그냥 작은 수로 놓겠다는 의미

        for q ← 1 to 4 {
            if (패턴 q가 패턴 p와 양립) {    ▷ 현재 패턴이 이전 패턴과 서로 조건이 맞다면 if문 통과, 즉 양립하는 모든 패턴을 검사함
                tmp ← pebble(i - 1, q);      ▷재귀 실행 -> 답을 구하고 다음 코드로 넘어감 
                if (tmp > max)
                    max ← tmp; 
            }
        }

        return (max + w[i, p]);              ▷ 현재 노드 + 이전 패턴의 최대 값
    }
}

pebbleSum(n)
 ▷n 열까지 조약돌을 놓은 방법 중 최대 점수 합 구하기
{
     return max { pebble(n, p) } ;
 }

 ▷ p =1,2,3,4
 ▷ pebble(i, 1), …, pebble(i, 4) 중 최대값이 최종적인 답
```

<br/>

### 돌 놓기 문제 & DP 

돌 놓기 문제를 DP를 활용하여 다음과 같이 풀 수 있다 

```ruby
pebble(n)
{
    for p ← 1 to 4
        peb[1][p] ← w[1][p];    ▷ peb 배열에 저장하며 불러오는 형식 

    for i ← 2 to n
        for p ← 1 to 4
            peb[i][p] ← max { peb[i-1][q] } + w[i][p];
                        // 단, q는 p와 양립하는 패턴

    return max { peb[n][p] } ;  // p = 1, 2, 3, 4
}
```






















































































