## 12 주차 

### 알고리즘 종류 정리

**프림 알고리즘** : 정점을 기준으로 **가장 가까운 정점을 추가**하는 방식 (MST(최소 신장 트리) 구하는 알고리즘 중 하나)

**크루스칼 알고리즘** : **오름차순** 정렬 후 **N-1번 반복하여 싸이클이 생기지 않으면** 간선을 선택 (MST(최소 신장 트리) 구하는 알고리즘 중 하나)

**위상정렬** : **진입 간선**이 없는 정점 선택 -> 정점을 따라가다 더이상 **진출 간선**이 없는 정점 발견 -> 처음부터 순서대로 배열에 넣음

**강연결 요소** : **DFS로 각 정점 v의 완료시간 f[v]** 를 계산 후 **간선을 역방향으로 전환**하여 f[v]이 가장 많이 소요된(가장 큰) 정점에서 시작

**다익스트라 알고리즘** : **최단 경로 문제**, 음의 가중치를 **허용하지 않는 경우** (0이상의 양수) 

**벨만-포드 알고리즘** : **최단 경로 문제**, 음의 가중치를 **허용하는 경우**, 단, 음의 가중치를 허용한다고해서 **싸이클에서의 가중치 합이 음이 되면 안 된다**

**싸이클이 없는 그래프의 경우** : **위상정렬** -> 기준점에서 **갈 수 있는** 거리만 계산

**플로이드-워샬** : 모든 정점 쌍에 대한 **행렬** 정점 k를 지나는 거리를 계산, **음의 가중치를 허용함**

**그리디(Greedy) 알고리즘** : 최적부분 구조, 탐욕 속성

<br/>

### 중요 개념 

**P** : 다항식 시간 내에 **답을 찾을 수 있는** 문제들의 집합 (알고리즘 파트에서 지금까지 다루어 온 많은 문제들이 여기에 속함)

**NP** : 	**정답이 주어졌을 때**, 그 정답이 다항식 시간 내에 **검증 가능한 문제의 집합**, 주의할 점은 **현실적인 시간에 풀 수 없지만**, 정답이 주어지면 검증은 다항식 시간 안에 할 수 있다는 것

**NP 완비** : NP에 속하며, **모든 NP 문제로부터 다항식 시간 내에 변환 가능한** 문제. NP 중 가장 어려운 문제들, 가장 어렵다의 기준의 바로 모든 NP 문제를 다항식 시간 내에 변환할 수 있다는 것, **답이 존재하는지도 모름 -> 답이 있냐 없냐를 결정하는 문제**

**NP-하드** : **모든 NP 문제로부터 다항식 시간 내 변환 가능**하지만, **꼭 NP에 속하지 않아도 되는** 문제 -> 모든 NP 문제를 문제 A로 바꿔서 풀 수 있다면, **문제 A만 풀 수 있어도 모든 NP 문제를 풀 수 있다**는 의미

- **NP는 P를 포함**하지만, 포함관계가 정확히 어떤지 **증명된 바가 없음** -> 경험적으로 대부분 P에 속하지 않은 NP 문제들이 있다고 추정

**상태공간트리(State-Space Tree)** : 문제 해결 과정의 **중간 상태**를 각각 하나의 노드로 나타낸 트리를 의미

<br/>

### 시간 복잡도 정리

프림 알고리즘 : O(ElogV)

크루스칼 알고리즘 : O(ElogV)

위상정렬 : Θ(V+E)

다익스트라 알고리즘 : O(|E|log|V|)

벨만-포드 : Θ(|V| x |E|)

플로이드-워샬 : Θ(|V|3)

싸이클이 없는 그래프 : Θ(V+E)

<br/>

### 시간 복잡도 정리

프림 알고리즘 : O(ElogV)

크루스칼 알고리즘 : O(ElogV)

위상정렬 : Θ(V+E)

<br/>

### 그래프 종류

Simple Graph : 방향 x,

Weighted Graph : 방향 x, 가중치 o

Directed Graph : 방향 o,

Weighted Directed Graph : 방향 o, 가중치 o

<br/>

### 강연결 요소

**강연결 요소** : 그래프 전체 대신 **강하게 연결된 부분 그래프**를 의미

- **강하게 연결 = 양방향 경로 존재**

- 종료시간이 빠르다 : 그 노드가 탐색에서 가장 깊이 들어가 있지 않았다, 즉 이어지는 노드가 많이 없다

- 종료시간이 느리다 : 그 노드가 탐색에서 가장 깊이 들어가 있다. 즉, 이어지는 노드가 많다

- **유향 그래프(Directed Graph)** 에서 서로 강하게 연결된 노드들의 집합을 찾는다

- SCC에 속한 노드들은 어떤 방향으로도 왕복이 가능

<br/>

### 강연결 요소에서 역을 수행하는 이유

역방향 탐색 수행 이유 : 일반적인 DFS로는 발견할 수 없는 강연결 요소(SCC)를 정확히 찾기 위함

<br/>

### 강연결 요소 과정 

DFS -> 간선 역으로 전환 -> 수행 시간 f[v]가 가장 큰 정점에서 다시 DFS 시작
![IMG_3262](https://github.com/user-attachments/assets/33fcb0f3-2bbc-4940-8310-98eb5be1136b)

![IMG_3261](https://github.com/user-attachments/assets/b94c61de-d3a4-423c-8ad5-7d65d36d15e7)

<br/>

### 강연결 요소 알고리즘 

```ruby
 stronglyConnectedComponent(G) 
{ 
1. 그래프 G에 대해 DFS를 수행하여 각 정점 v의 완료시간 f [v]를 계산한다

2. G의 모든 간선들의 방향을 뒤집는다

3. DFS(그래프 G의 간선 역방향)를 수행하되 시작점을 1번에서 구한 f[v]가 가장 큰 정점으로 잡는다

4. 3과정에서 만들어진 분리된 트리들 각각을 강연결요소로 리턴한다

}
```

<br/>

### 최단 경로

**최단 경로 문제** : 그래프에서 두 정점 사이의 경로 중에서 가중치 합이 가장 작은 경로를 찾는 문제

다익스트라, 벨만포드,플로이드 워샬 존재 

<br/>

### 다익스트라 알고리즘

음의 가중치를 **허용하지 않음**
  
![IMG_3265](https://github.com/user-attachments/assets/a0f87912-b3df-4988-8fb1-15bd7e603d0f)

![IMG_3266](https://github.com/user-attachments/assets/e17f6122-f350-43da-a516-bd1dfaffbb43)


<br>

### 다익스트라 알고리즘 시간 복잡도 O(|E|log|V|)

```ruby
Dijkstra(G, r)                       // G: 그래프 (V, E), r: 시작 정점
▷ G = (V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
    S ← ∅ ;                          // S: 최단 거리가 확정된 정점들의 집합 (초기에는 공집합)

    for each u ∈ V                   // 그래프의 모든 정점 u에 대해
        d[u] ← ∞ ;                   // d[u]: 시작점 r에서 u까지의 최단 거리 추정값 (초기에는 무한대)
    d[r] ← 0 ;                       // 시작 정점 r의 거리는 0으로 설정

    while (S ≠ V) {                  // 모든 정점의 최단 거리가 확정될 때까지 반복
        u ← extractMin(V - S, d) ;   // S에 포함되지 않은 정점들 중에서 d값이 가장 작은 정점 u 선택
        S ← S ∪ {u} ;                // u의 최단 거리를 확정하고 S에 추가

        for each v ∈ L(u)            // u와 인접한 정점 v에 대해 반복
            if (v ∈ V-S and d[u] + w[u, v] < d[v]) then {   // u를 통해 v로 가는 경로가 더 짧다면
                d[v] ← d[u] + w[u, v] ;                   // d[v]를 더 짧은 거리로 갱신 (이완)
                prev[v] ← u ;                             // prev[v]에 u 저장 → 경로 추적을 위함
            }
    }
}
```

<br/>

## 13주차 

### 벨만-포드 알고리즘

**음의 가중치가 있는 그래프**에서도 사용 가능한 최단 경로 알고리즘

<br/>

### 벨만-포드 알고리즘 코드 

```ruby
BellmanFord(G, r)  // G는 그래프, r은 시작 정점
{
    for each u ∈ V              // 모든 정점 u에 대해
        d[u] ← ∞;               // 거리 값을 무한대로 초기화
    d[r] ← 0;                   // 시작 정점 r의 거리는 0으로 설정

    for i ← 1 to |V| - 1        // 정점 수 - 1번 반복 (최악의 경우 모든 간선을 이완)
        for each (u, v) ∈ E     // 모든 간선 (u, v)에 대해
            if (d[u] + w[u, v] < d[v]) then { // u를 거쳐 v로 가는 경로가 더 짧다면
                d[v] ← d[u] + w[u, v];        // 거리 값을 갱신 (이완: relaxation)
                prev[v] ← u;                  // 최단 경로 상 이전 정점을 기록
            }

    // 음의 사이클 존재 여부 확인
    for each (u, v) ∈ E
        if (d[u] + w[u, v] < d[v])  // 여전히 더 짧은 경로가 있다면
            output "해없음";       // 음의 사이클 존재함

   
}
```

<br/>

### 벨만-포드 시간복잡도 : 시간 복잡도 : Θ(|V| x |E|)

<br/>


### 벨만 포드 cont'd : 만약 |V|개를 탐색한다면?

만약 |V|개 이상의 간선으로 이루어진 최단 경로가 존재한다면 경로 상에 반드시 하나 이상의 사이클이 존재할 것이다

이 경우, 최단 경로 문제에서 사이클에서의 가중치 합은 음이 될 수 없으므로 (음의 무한대로 향해서 답을 구할 수 없음) 반드시 0 이상이여야 한다

그러나 만약 사이클에서의 가중치 합이 0 초과라면 사이클을 제외하여 경로 전체의 가중치 합을 낮출 수 있으므로 최단 경로라는 가정을 위배하게 된다

가중치 합이 0이어도 사이클을 제외하여 더 적은 수의 간선으로 최단 경로를 만들 수 있어서 오류가 발생한다

<br/>

### 다익스트라, 벨만 포드 차이 

- **다익스트라** : 한번 최단으로 판단된 경로는 그 이후에 변경되지 않아서 더 짧은 경로를 찾을 수 없다는 (**다익스트라 문제점**) 

- **벨만-포드** : 모든 턴마다 모든 간선의 수를 비교하여 **확실하게 최단경로**를 구할 수 있다 , 하지만 시간이 좀 걸린다는 **문제가 존재**

<br/>

### 플로이드-워샬 알고리즘

- **동적 프로그래밍**을 이용하여 모든 정점 쌍에서의 최단 경로를 구함

- **음의 가중치를 허용함**

<br/>

### 플로이드-워샬 과정 예시 1

![IMG_3327](https://github.com/user-attachments/assets/eaf64e8a-a023-49ff-84af-45de15272e51)

![IMG_3328](https://github.com/user-attachments/assets/d89ef156-f8f4-4370-a4d1-7479a084ddcc)

![IMG_3324](https://github.com/user-attachments/assets/0069e337-232d-4a18-8ae1-9bba0f878ace)

![IMG_3325](https://github.com/user-attachments/assets/408914b9-4e62-4e8c-a25c-d70a40741ea1)

![IMG_3326](https://github.com/user-attachments/assets/0fd2fb34-dada-4f43-8b4b-6624dda6b82d)

<br/>

### 플로이드-워샬 과정 예시 2

![IMG_3331](https://github.com/user-attachments/assets/db78a756-5ce6-4089-b48d-469ed8fa0167)

![IMG_3332](https://github.com/user-attachments/assets/95e5b91a-3b91-4882-ba22-182e496042a2)

<br/>

## !4주차 

### 그리디(Greedy) 알고리즘

**그리디 알고리즘(Greedy algorithm)** : 이름처럼 **눈앞의 이익**만 취하고 보는 알고리즘을 뜻함

- 전체적으로 봤을 때 **최적이라고 보장하진 않지만**, **현재 시점에서 가장 이득**인 것으로 보이는 해를 선택하는 행위를 반복. **드물게 최적해가 보장되는 경우 존재**

- **다익스트라 알고리즘은 DP가 아니라 그리디 알고리즘으로 판단**

- **그리디 알고리즘**으로 풀 수 있다면 **항상 그에 대한 동적 프로그래밍 방식의 답안이 존재** -> (by 그리디 알고리즘 조건 중 최적 부분 구조)

<br/>

### 그리디 알고리즘 조건

- **최적 부분 구조** : 그리디 알고리즘도 현재 가장 좋은 값을 탐색하다 보면 언젠간 마지막의 답이 존재해야함

- **탐욕 선택 속성** : 현재 선택이 전체 최적해에 포함된다는 보장이 있어야 함

<br/>

### Activity-selection problem

Activity-selection problem은 회의실 배정 문제와 같은 문제

목표 : 시작시간 및 종료시간이 표시된 여러 개의 활동들이 있을 때, 주어진 시간 내에서 최대 개수의 활동을 하는 것을 목표로 함

한 활동이 끝나기 전에 다른 활동을 시작할 수는 없다

각 활동은 시작시간 si, 종료시간 fi로 표현

아래 예시를 함께 보자

각 활동 𝑎𝑖의 index가 종료시간 순서에 맞게 매겨져 있다고 가정한다 또한, 시간에 따른 표 이므로 i가 커질수록 종료 시간이 더 늦어진다

![IMG_3344](https://github.com/user-attachments/assets/3241ed15-df96-49df-ac1f-9da6f19e6984)

<br/>

### Activity-selection problem를 그리디로 풀 수 있는지 증명 파트 보기 

<br/>

### 그리디 알고리즘 설계 과정

1. 주어진 문제에 대해 그리디 방식의 선택을 했을 때 **단 하나의 부분문제**만 남는지 확인

2. 그리디 선택을 해도 **최적해**를 구할 수 있음을 보인다 -> **그리디 선택 성질 확인**

3. 그리디 선택에 대한 **부분 최적구조**를 도출한다

4. 해당 부분 최적구조를 바탕으로 알고리즘을 설계한다

<br/>

### 그리디 선택 성질

**그리디 선택 성질** : 그리디 선택으로도 최적해를 구할 수 있다는 것을 보이는 것

<br/>

## 15주차 

### NP 완비 

**P** : 다항식 시간 내에 **답을 찾을 수 있는** 문제들의 집합 (알고리즘 파트에서 지금까지 다루어 온 많은 문제들이 여기에 속함)

**NP** : 	**정답이 주어졌을 때**, 그 정답이 다항식 시간 내에 **검증 가능한 문제의 집합**, 주의할 점은 **현실적인 시간에 풀 수 없지만**, 정답이 주어지면 검증은 다항식 시간 안에 할 수 있다는 것

**NP 완비** : NP에 속하며, **모든 NP 문제로부터 다항식 시간 내에 변환 가능한** 문제. NP 중 가장 어려운 문제들, 가장 어렵다의 기준의 바로 모든 NP 문제를 다항식 시간 내에 변환할 수 있다는 것, **답이 존재하는지도 모름 -> 답이 있냐 없냐를 결정하는 문제**

**NP-하드** : **모든 NP 문제로부터 다항식 시간 내 변환 가능**하지만, **꼭 NP에 속하지 않아도 되는** 문제 -> 모든 NP 문제를 문제 A로 바꿔서 풀 수 있다면, **문제 A만 풀 수 있어도 모든 NP 문제를 풀 수 있다**는 의미

- **NP는 P를 포함**하지만, 포함관계가 정확히 어떤지 **증명된 바가 없음** -> 경험적으로 대부분 P에 속하지 않은 NP 문제들이 있다고 추정

<br/>

### 컴퓨터 과학에서 다루는 문제의 종류

- **결정 문제** : 결과가 Yes/No로 나오는 문제 (ex: n개의 지점을 모두 방문하고 돌아오는 거리 K 이하의 경로가 존재하는가?)

- **최적화 문제** : 결과가 가능한 출력들 중 가장 좋은 해로 나오는 문제 (ex: n개의 지점을 모두 방문하고 돌아오는 최단 거리를 구하라)

**NP-완비 이론**은 **결정 문제**만 다루지만, **최적화 문제**는 NP-완비 이론 적용을 위해 **그에 해당하는 결정 문제로 미리 변환 가능함**

<br/>

### 다항식 시간 변환 

![IMG_3362](https://github.com/user-attachments/assets/de02f442-ad10-4448-81a6-f0ae15356374)

만약 어느 정도 어려운지 모르는 문제 B가 있다고 하면, 유명한 난제군인 NP-완비군에 속하는 문제를 문제 A로 놓고 A를 B로 변환할 수 있다면, 문제 B는 NP-하드라는 굉장히 어려운 문제군

NP 하드 문제에서는 **NP가 아닌 문제가 존재, 하지만 이것은 P는 아님**

<br/>

### NP-완비 조건 

![IMG_3421](https://github.com/user-attachments/assets/cc948969-81f7-4c48-80f0-22e2c237f281)

정리와 같이 문제 A가 두 가지 조건을 만족해야 NP-완비 문제가 된다 

1. **A는 NP이다**

2. **A는 NP하드이다**

<br>

NP-하드 문제의 개념만 보면, 어떤 문제가 NP-하드임을 보이려면 모든 NP 문제로부터 다항식 시간 변환이 가능함을 보여야 한다. 하지만 이건 현실적으로 불가능에 가깝다 (NP 문제는 무한히 많음)

그래서 우리는 **이미 NP-하드로 알려진 대표 문제로부터** 해당 문제를 다항식 시간에 변환해 주면 됨

<br/>

## 16주차 

### 상태공간트리(State-Space Tree)

상태공간트리(State-Space Tree) : 문제 해결 과정의 중간 상태를 각각 하나의 노드로 나타낸 트리를 의미

<br/>

### TSP 예시 

- 왼쪽 표: 각 도시 간 거리 행렬 (1~5 도시)

- 오른쪽 그래프: 도시 간 거리 기반의 완전 그래프 (각 도시 간 간선 있음)

![IMG_3439](https://github.com/user-attachments/assets/7333661c-fd57-4b0b-b8e4-dcd01f055e05)

![IMG_3438](https://github.com/user-attachments/assets/4a02e185-b536-46d2-aec1-ea984bbc002b)

해당 트리를 보면 다음과 같이 트리가 작성되었다 

- Depth 0 (루트): 1개 (1)

- Depth 1 (1-2, 1-3, 1-4, 1-5): 4개

- Depth 2 (예: 1-2-3, 1-2-4, ...): 12개 (각 depth 1 노드당 3개씩 → 4×3=12)

- Depth 3 (예: 1-2-3-4, 1-2-3-5, ...): 24개 (각 depth 2 노드당 2개씩 → 12×2=24)

각 계산은 경우의 수 이용 (1은 고정되어 있고 2,3,4,5 끼리 순서를 정하는 것 ex: Depth 3은 1은 고정되어 있고, 첫번째로 올 수 있는 수는 4개 다음은 3개 그 다음은 2개 -> 4x3x2 = 24)



































