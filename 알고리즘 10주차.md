## 그래프

**그래프** : 정점(vertex) 및 간선(edge)로 이루어진 자료구조

- G = (V, E) 형태로 나타냄

- V: 정점 집합

- E: 간선 집합

**인접(adjacent)** : 두 정점이 간선으로 연결되어 있을 경우 인접하다고 함

<br/>

## 그래프의 종류를 나누는 기준 

1. 두 vertex 간 가능한 edge의 개수

2. Edge의 방향 유무

3. Loop의 유무 (Loop : 정점이 자기 자신으로 다시 연결되는 간선)

4. 추가적으로 edge의 weight 유무에 따라 weighted, unweighted로 나눌 수 있음

<br/>

## simple graph 예시 

**특징**

- 방향이 없음

![image](https://github.com/user-attachments/assets/6ba05574-f4d6-4512-b7e1-ac0a0b37e222)

<br/>

## weighted graph 예시 

**특징**

- 가중치가 존재

- Simple graph + weight 구조 

![image](https://github.com/user-attachments/assets/265eed82-f844-44cc-885b-cf28c3171b48)

ex) 철수와 영희의 친밀도는 9이다

<br/>

## Directed graph (=digraph, 유향 그래프)

**특징**

- 양방향이 존재 (단방향도 가능)

![image](https://github.com/user-attachments/assets/86a0afb1-8792-4626-a644-26342743e971)

ex) 철수와 영희는 서로 아는 사이이다 

<br>

## 가중치를 가진 유향 그래프

**특징**

- 가중치와 방향을 모두 가짐

![image](https://github.com/user-attachments/assets/d452364d-f37f-48b5-ac8b-8b9ecd63f6e7)

<br/>

## 인접 행렬 (Adjacency matrix)

![IMG_3191](https://github.com/user-attachments/assets/4fadf02e-67f6-4a99-9d89-cc90a6be6fa2)

**인접 행렬** : 𝑁이 정점의 총 수를 나타낼 때, 𝑁×𝑁로 그래프를 표현한 것 

- 원소 (i,  j) = 1 : 정점 i 와 정점 j 사이에 간선이 있음

- 원소 (i,  j) = 0 : 정점 i 와 정점 j 사이에 간선이 없음

<br/>

**유향 그래프의 경우**

- 원소 (i,  j)는 정점 i로부터 정점 j로 연결되는 간선이 있는지를 나타냄

**가중치가 있는 그래프의 경우**

- 원소 (i,  j)는 1 대신에 가중치를 가짐

<br/>

## 인접 행렬 - 무향(방향x) 그래프 예시 

![IMG_3190](https://github.com/user-attachments/assets/b9af4710-0cea-4dbf-9eb2-c52d543da226)

<br/>

## 인접 행렬 - 가중치가 있는 무향 그래프의 예시

아래 예시도 마찬가지로 방향이 없기 때문에 **대칭적이다**

![image](https://github.com/user-attachments/assets/f082d1d2-ad3e-45a9-a313-eafced2f2464)

<br/>

## 인접 행렬 - 유향 그래프 예시 

![IMG_3192](https://github.com/user-attachments/assets/fa1590de-ad48-44bf-8751-46dc9f66c4f1)

<br/>

## 인접 행렬 - 가중치가 있는 유향 그래프의 예시

![image](https://github.com/user-attachments/assets/4cb9838b-17e6-4d6e-8857-1b35e12a680f)

<br/>

## 그래프 장단점 

**인접 행렬**을 이용했을 때의 각각의 **장단점**은 다음과 같다 

**장점** : 이해하기 쉽고 간선의 존재 여부를 Θ(1)만에 파악 가능

**단점** :  그래프 정보를 저장하기 위해서만 **Θ(n^2) 시간이 소요**되고 (NxN 행렬이기 때문) **메모리 사용량도 크다**는 단점이 존재

또한, 간선의 밀도가 높은 그래프에서는 인접 행렬을 사용한 표현이 적합하나, **정점의 수 대비 간선이 적은 경우**에는 **대부분의 원소가 0으로 이루어지기 때문에** 인접 행렬을 이용한 표현은 **비효율적**이다 

이렇게 대부분 원소가 0으로 이루어진 현상을 **스케일 프리 네트워크 라고한다**

<br/>

## 스케일 프리 네트워크 

**스케일 프리 네트워크** : 특정 노드(허브, Hub)들이 매우 많은 연결을 가지며, **대부분의 다른 노드들은 몇 개의 연결**만 가지는 네트워크 구조를 의미한다 

스케일 프리 네트워크에서 인접 행렬을 사용하면 **메모리 낭비가 매우 심하다**

만약 1만 개의 노드 중 1%만 연결되어 있다면, **대부분의 인접 행렬 값이 0이 된다**

예를 들어, 10,000개의 노드라면 **100,000,000개의 메모리 공간이 필요**하지만 이것의 거의 표현할 수 없는 단계에 도달한다 

<br/>

## 인접 리스트(Adjacency list)

**인접 리스트** : N개의 연결 리스트로 각 정점에서 시작하는 간선들을 표현하는 것을 의미한다

- i번째 리스트는 정점 j에 인접한 정점들을 리스트로 연결해 놓음

- 가중치 있는 그래프의 경우 리스트에 가중치도 보관한다

![IMG_3193](https://github.com/user-attachments/assets/d9d585fd-d026-4891-b2ce-6a8395221812)

![IMG_3195](https://github.com/user-attachments/assets/bb5f9805-6509-42f6-81f4-bc4d3b99fe1d)

<br/>

## 인접리스트 장단점 

**장점** : 인접 리스트는 메모리 사용량 측면에서는 인접 행렬보다 효율적일 수 있음

단점 : 특정 정점에 대해 이어진 간선을 검색하고자 하는 경우 **worst case로는 Θ(𝑛)의 시간이 소요**될 수 있다

이에 **인접 리스트**는 **간선의 밀도가 낮을 때 유용**하다 

<br/>

정리하면 

- **인접 행렬**은 간선의 밀도가 **높을 때** 유용

- **인접 리스트**는 간선의 밀도가 **낮을 때** 유용

<br/>

## 그래프 순회 (Graph Traversal)

**그래프 순회** : 그래프 내의 **모든 정점을 한번씩 방문**하는 연산을 의미

컴퓨터 과학에서 그래프 탐색(그래프 검색이라고도 함)은 그래프의 각 정점을 방문(확인 및/또는 업데이트)하는 과정을 의미한다

<br/>

대표적으로 아래와 같은 두 가지 방법이 존재함

- **BFS** (Breadth-First Search) : 너비 우선 탐색

- **DFS** (Depth-First Search, DFS) : 깊이 우선 탐색

위의 두 가지 방법은 모두 연결 그래프(connected graph, 모든 두 정점 사이에 경로가 존재)를 가정한 것이며, 분리된 그래프에 대해서는 **부분 그래프 수 만큼 실행해야 모든 정점을 탐색 가능**

<br/>

## 너비 우선 탐색 (BFS, Breadth-First Search)

**너비 우선 탐색 (BFS, Breadth-First Search)** : 루트 노드(혹은 다른 임의의 노드)에서 시작해서 **인접한 노드를 먼저 탐색**하는 방법

즉 , 시작 정점으로부터 **가까운 정점을 먼저 방문**하고 **멀리 떨어져 있는 정점을 나중에** 방문하는 순회 방법

ex) 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash 와 Vanessa 사이에 존재하는 경로를 찾는 경우 BFS가 적절 

<br/>

## 너비 우선 탐색(BFS)의 특징

- BFS 는 **재귀적으로 동작하지 않는다**

- 이 알고리즘을 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 어떤 노드를 방문했었는지 **여부를 반드시 검사**해야한다는 것이다 이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다

- BFS 는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 **큐(Queue)를 사용함**

- **선입선출(FIFO) 원칙**으로 탐색

<br/>

## BFS 과정 

![IMG_3198](https://github.com/user-attachments/assets/64a402a1-993e-412a-b98b-f909a6fe0eff)

<br/>

![IMG_3199 (1)](https://github.com/user-attachments/assets/47a6f9f0-23d5-4e3f-a0f7-7f422fc9d4aa)

<br/>

## 너비 우선 탐색 (BFS) 알고리즘

```ruby
BFS(G, s)
{
    for each v ∈ V - {s}
        visited[v] ← NO;
    visited[s] ← YES;
    enqueue(Q, s);
    
    while (Q ≠ ∅) {
        u ← dequeue(Q);
        for each v ∈ L(u) 
            if (visited[v] = NO) {
                visited[v] ← YES;
                enqueue(Q, v);
            }
        
    }
}
```








































