## 동적 프로그래밍(Dynamic Programming, DP)

**동적 프로그래밍** : 큰 문제의 해답에 **더 작은 문제의 해답**이 포함되어 있으며, 이를 재귀호출로 구현할 때 같은 해답을 구하기 위한 중복 호출이 다수 발생하는 경우에 활용하는 문제해결 기법

동적 프로그래밍의 목적은 재귀를 사용했을 때 같은 연산을 반복해야하는 비효율적인 연산을 해결하기 위해 **계산된 값을 메모리에 저장해** 두 번 다시 계산하지 않기 위함이다 

큰 문제의 해답에 **더 작은 문제의 최적의 해답**이 포함된 경우를 **최적 부분 구조(Optimal Substructure)** 를 가진다고 한다

<br/>

최적 부분 구조를 피보나치 수열로 예를 들면, fib(5) = fib(4) + fib(3)으로 나눠질 때, fib(4)와 fib(3)를 구하려면 더 내려가야하고 fib(2) 또는 fib(1)에 도달했을 때 값을 구하는 구조를 의미한다 

중요한 것은 식을 쪼갠 다음에 각각 **작은 문제의 최적 답**만 잘 모으면 해답이 존재하는 것이 최적 부분 구조이다

<br/>

**피보나치 예시**

![image](https://github.com/user-attachments/assets/5b8af235-fc63-454e-90de-3b32b803d994)

위 코드에서 fib(7)만 실행해도 아래와 같이 fib(2)가 8번이나 반복 연산을 해야하고 n값이 증가할수록 반복 연산의 수가 기하급수적으로 커진다 

![image](https://github.com/user-attachments/assets/8afaf7f2-5c45-494c-a2fc-81c0aecd1a13)

위와 같은 반복 연산의 문제를 **동적 프로그래밍을 통해 해결할 수 있다**

<br/>

## 피보나치 & 동적 프로그래밍

피보나치를 **f라는 배열을 이용하여** 동적 프로그래밍을 해결한 코드를 보자 

![image](https://github.com/user-attachments/assets/24408eed-5592-4730-870e-2a4a743e28c0)

위 코드와 같이 동적 프로그래밍은 재귀가 아니라 **저장을 하여 사용한다는 것이 특징**이다

<br/>

초기 배열은 모두 0값으로 초기화를 하고, 처음 부터 계산을 하며 저장을 하는 방식이다. 

이렇게 되면 만약 f[10]을 구할 때 f[9]와 f[8]이 필요하고, 이 값들은 이미 아래서부터 계산이 되어 저장을 시키며 올라왔기 때문에 그냥 가져오면 된다

즉, **재귀는 O(2^n)** 이 걸리지만. 배열을 사용하면 **처음 연산 이후** 값을 가져오는데 **O(1)** 이 걸리기 때문에 훨씬 효율적이다 

<br/>

## 동적 프로그래밍 적용 성질 

동적 프로그래밍을 적용하는 문제는 아래와 같은 두 성질이 있다 

- 최적 부분 구조 :  큰 문제의 최적 솔루션에 **작은 문제의 최적 솔루션이 포함**, 즉 하위 레벨로 갔을 때 **해답이 존재해야 함**

- 중복되는 부분 문제 : 재귀적 해법으로 풀면 같은 문제에 대한 **재귀호출이 심하게 중복되는** 문제 

<br/>

## 동적 프로그래밍 예시 

재귀 호출을 활용한 동적 프로그래밍 예시는 아래와 같다 

![image](https://github.com/user-attachments/assets/0267ecc7-742f-4e6c-86a0-9e03b9463a29)

- 재귀 호출을 사용하지만, 미리 계산한 값이 있는지 확인하여 중복 연산을 피함

- 이러한 방식도 동적 프로그래밍의 일종

<br/>

이와 같은 방식을 **하향식(Top-down)** 방식이라고하며, 앞서 다룬 것과 같이 i=1부터 계산하면서 올라가는 방식은 **상향식(Bottom-up)** 방식이라 함

상향식이 더 자주 활용되나 둘 다 동적 프로그래밍의 범주에 속한다 

<br/>

## 행렬 경로 문제 

문제 상황 : 양수 원소들로 구성된 n×n 행렬이 주어지고, 행렬의 좌상단에서 시작하여 우하단까지 이동하는 상황을 가정한 문제

**이동 방법 (제약조건)**

- 오른쪽이나 아래쪽으로만 이동할 수 있다

- 왼쪽, 위쪽, 대각선 이동은 허용하지 않는다

<br/>

**목표**

행렬의 좌상단에서 시작하여 우하단까지 이동하되, 방문한 칸에 있는 수들을 더한 값이 최대화되도록 한다

![image](https://github.com/user-attachments/assets/1a96ffb7-ea46-4ed0-ab49-a12945da1060)

<br/>

**행렬 경로 문제 코드**

![image](https://github.com/user-attachments/assets/17a0d789-e040-4240-baff-a9533ceb1c9c)

- m[i][j] : 행렬의 각 칸에 있는 숫자

- c[i][j] : (1,1)에서 시작해서 (i,j)에 도달할 수 있는 최대 점수

- 점수는 이동 경로 중 방문한 칸의 수를 누적해서 계산함

<br/>

위 문제가 동적 프로그래밍과 관련이 있는 이유는 **재귀함수**로 되어있고, 점차적으로 **최적의 해답으로** 향하기 때문이다

처음 a칸 -> b칸 -> ..  -> k칸으로 이동할 때, 각 칸의 수가 누적이 된 채로 다음 칸을 계산한다 

이 방식은 피보나치와 유사하며 동적 프로그래밍으로 접근할 수 있다. 

<br/>

추가적으로, 최적 부분 구조에서 더 작은 문제의 **최적의 해답**을 찾는 것이였는데 피보나치는 경로가 일정하고 규칙적이여서 단 하나만 존재하였다. 

그래서 그 경로가 결국 최적의 해가 된 것인데 

행렬 경로 문제는 다양하게 접근할 수 있고, 최종적으로 도달했을 때 각 경로마다 결과가 다를 수 있으므로 이 중 최적의 해를 구해야 한다 

<br/>

**행렬 경로 문제 코드 결과**

![IMG_3153](https://github.com/user-attachments/assets/3b4579ef-d462-4222-a270-ff998ac73347)

이렇게 코드를 만들면, 시간복잡도가 **O(2^(n+m))** 이 소요돼서 너무 오래 걸린다 (n x m 행렬)

<br/>

## 행렬 경로 문제 & DP

위에서 행렬 경로 문제를 아래와 같이 DP로 코드를 작성하면 결국 행렬의 모든 칸을 검사히기 때문에 **Θ(𝑛2)** 의 시간 복잡도를 가지며 행렬의 총 원소 수에 대해서 선형 시간으로 볼 수 있다 

```ruby
matrixPath(n) 
▷(n, n)에 이르는 최고점수 
{ 

for i ← 0 to n
    c[i, 0] ← 0; 

for j ← 1 to n
    c[0, j] ← 0; 

for i ← 1 to n
    for j ← 1 to n
       c[i, j] ← mij + max(c[i-1,  j], c[i,  j-1]); 

return c[n, n]; 
}
```

![IMG_3154](https://github.com/user-attachments/assets/597139cf-2094-4810-8f7b-c986807dc827)

<br/>

## 돌 놓기 문제

돌 놓기 문제는 3 × 𝑛 행렬의 각 칸에 양 또는 음의 정수가 기록되어 있으며, 해당 행렬에 돌을 놓는 상황이다

돌을 놓을 때의 제약조건은 다음과 같다 

- 가로나 세로로 인접한 두 칸에 동시에 조약돌을 놓을 수 없다

- 각 열에는 적어도 하나 이상의 조약돌을 놓는다

<br/>

목표: 돌이 놓인 자리에 있는 수들의 **합이 최대**가 되도록 돌 놓기

![image](https://github.com/user-attachments/assets/5b6f6baa-6136-466d-96ef-ff771c0dab51)

<br/>

**예시**

![image](https://github.com/user-attachments/assets/544b23da-bd9d-42fa-927f-c45011eea3ed)

<br/>

돌 놓기 문제에서 임의의 열을 채울 수 있는 패턴은 아래와 같이 4가지가 존재한다 

![image](https://github.com/user-attachments/assets/67c26a6c-21ed-4440-807f-cda42660562f)

<br/>

패턴별로 서로 인접한 열에서 양립할 수 있는 패턴들을 정리해보면 아래와 같다 

직사각형 아래에 표시된 숫자가 패턴의 번호이다 

![image](https://github.com/user-attachments/assets/65121e32-3250-4bfb-9e7e-d1d35350c578)

즉, i = 1번째인 열부터 시작하여(처음 시작하는 열) 다음 열로 갈 때 만약 내가 현재 열의 맨 위에다가 돌을 두고 싶다면(패턴이 1인 경우), 이전 패턴이 2 또는 3이여햐만 하고, 이때 최대 합을 구하여 비교하는 방식으로 코드를 작성할 수 있다 

아래 코드를 살펴보자 

<br/>

```ruby
pebble(i, p)
▷i열이 패턴 p로 놓일 때의 i열까지의 최대 점수 합 구하기
▷w[i, p] : i 열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수 합.  p = {1, 2, 3, 4}
{
    if (i == 1)
        return w[1, p];
    else {
        max ← -∞;  ▷ 초기 max값을 그냥 작은 수로 놓겠다는 의미

        for q ← 1 to 4 {
            if (패턴 q가 패턴 p와 양립) {    ▷ 현재 패턴이 이전 패턴과 서로 조건이 맞다면 if문 통과, 즉 양립하는 모든 패턴을 검사함
                tmp ← pebble(i - 1, q);      ▷재귀 실행 -> 답을 구하고 다음 코드로 넘어감 
                if (tmp > max)
                    max ← tmp; 
            }
        }

        return (max + w[i, p]);              ▷ 현재 노드 + 이전 패턴의 최대 값
    }
}
```

<br/>

위 코드의 재귀 함수는 다음과 같이 진행된다 

재귀 함수가 내려오다 i=1이 되면 해당 노드의 값을 반환한다 (by if (i == 1) -> return w[1, p];)

만약 처음 시작할 때 돌을 **(1,1)**에 놓는다면, 다음 열에는 **(2,2)와 (2,3**에 놓을 수 있다

즉, 여기서 for문의 if문이 성립이 된다 

그럼 (2,3)에 상황을 예시로 들겠다. 상황은 아래와 같다 

```ruby
pebble(2, 3) → pebble(1, 1) 호출 → w[1][1] 반환
```

<br/>

위 코드의 pebble(2,3)은 다음과 같이 계산이 된다 

```ruby
max = w[1][1]   ← 이전 결과
pebble(2, 3) = max + w[2][3]  ← 자기 열의 점수 더함
```

위의 과정과 같이 for문은 1~4의 패턴을 모두 확인하며, 가능한 패턴을 모두 검사하여 **최종 max을 도출**하는 방식이다 

