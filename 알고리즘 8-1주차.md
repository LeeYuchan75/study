## 동적 프로그래밍

**동적 프로그래밍** : 큰 문제의 해답에 **더 작은 문제의 해답**이 포함되어 있으며, 이를 재귀호출로 구현할 때 같은 해답을 구하기 위한 중복 호출이 다수 발생하는 경우에 활용하는 문제해결 기법

동적 프로그래밍의 목적은 재귀를 사용했을 때 같은 연산을 반복해야하는 비효율적인 연산을 해결하기 위해 **계산된 값을 메모리에 저장해** 두 번 다시 계산하지 않기 위함이다 

큰 문제의 해답에 **더 작은 문제의 해답**이 포함된 경우를 **최적 부분 구조(Optimal Substructure)** 를 가진다고 한다

<br/>

최적 부분 구조를 피보나치 수열로 예를 들면, fib(5) = fib(4) + fib(3)으로 나눠질 때, fib(4)와 fib(3)를 구하려면 더 내려가야하고 fib(2) 또는 fib(1)에 도달했을 때 값을 구하는 구조를 의미한다 

중요한 것은 식을 쪼갠 다음에 각각 **작은 문제의 최적 답**만 잘 모으면 해답이 존재하는 것이 최적 부분 구조이다

<br/>

**피보나치 예시**

![image](https://github.com/user-attachments/assets/5b8af235-fc63-454e-90de-3b32b803d994)

위 코드에서 fib(7)만 실행해도 아래와 같이 fib(2)가 8번이나 반복 연산을 해야하고 n값이 증가할수록 반복 연산의 수가 기하급수적으로 커진다 

![image](https://github.com/user-attachments/assets/8afaf7f2-5c45-494c-a2fc-81c0aecd1a13)

위와 같은 반복 연산의 문제를 **동적 프로그래밍을 통해 해결할 수 있다**

<br/>

## 피보나치 & 동적 프로그래밍

피보나치를 **f라는 배열을 이용하여** 동적 프로그래밍을 해결한 코드를 보자 

![image](https://github.com/user-attachments/assets/24408eed-5592-4730-870e-2a4a743e28c0)

위 코드와 같이 동적 프로그래밍은 재귀가 아니라 **저장을 하여 사용한다는 것이 특징**이다

<br/>

초기 배열은 모두 0값으로 초기화를 하고, 처음 부터 계산을 하며 저장을 하는 방식이다. 

이렇게 되면 만약 f[10]을 구할 때 f[9]와 f[8]이 필요하고, 이 값들은 이미 아래서부터 계산이 되어 저장을 시키며 올라왔기 때문에 그냥 가져오면 된다

즉, 재귀는 O(2^n)이 걸리지만. 배열을 사용하면 값을 가져오는데 O(1)이 걸리기 때문에 훨씬 효율적이다 


























