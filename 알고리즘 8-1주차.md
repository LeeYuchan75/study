## 동적 프로그래밍(Dynamic Programming, DP)

**동적 프로그래밍** : 큰 문제의 해답에 **더 작은 문제의 해답**이 포함되어 있으며, 이를 재귀호출로 구현할 때 같은 해답을 구하기 위한 중복 호출이 다수 발생하는 경우에 활용하는 문제해결 기법

동적 프로그래밍의 목적은 재귀를 사용했을 때 같은 연산을 반복해야하는 비효율적인 연산을 해결하기 위해 **계산된 값을 메모리에 저장해** 두 번 다시 계산하지 않기 위함이다 

큰 문제의 해답에 **더 작은 문제의 최적의 해답**이 포함된 경우를 **최적 부분 구조(Optimal Substructure)** 를 가진다고 한다

<br/>

최적 부분 구조를 피보나치로 예를 들자면, f(n) = f(n-1) + f(n-2) 에서 f(n)은 이것의 작은 문제인 f(n-1)과 f(n-2)의 해답을 이용하여 풀 수 있고, f(n-1)과 f(n-2)는 base case 부터 올라가며 답을 얻을 수 있다

큰 문제의 해답에 더 작은 문제의 해답이 포함된다는 것은 **단순히 base case가 존재한다고 만족하는 것이 아니라**, 이 base case를 이용하여 **f(n)을 구하기 위한 모든 하위 단계를 구할 수 있어야 한다**

만약 base case를 알고 있지만 식 변형에 의해 f(5) = f(4) + f(3)에서 f(4)를 구할 수 없는 구조라면, f(5)를 구하기 위한 더 작은 모든 문제들의 해답이 완벽하게 존재하지 않으므로 최적 부분 구조가 아닌 것이다

<br/>

**피보나치 예시**

![image](https://github.com/user-attachments/assets/5b8af235-fc63-454e-90de-3b32b803d994)

위 코드에서 fib(7)만 실행해도 아래와 같이 fib(2)가 8번이나 반복 연산을 해야하고 n값이 증가할수록 반복 연산의 수가 기하급수적으로 커진다 

![image](https://github.com/user-attachments/assets/8afaf7f2-5c45-494c-a2fc-81c0aecd1a13)

위와 같은 반복 연산의 문제를 **동적 프로그래밍을 통해 해결할 수 있다**

<br/>

## 피보나치 & 동적 프로그래밍

피보나치를 **f라는 배열을 이용하여** 동적 프로그래밍을 해결한 코드를 보자 

![image](https://github.com/user-attachments/assets/24408eed-5592-4730-870e-2a4a743e28c0)

위 코드와 같이 동적 프로그래밍은 재귀가 아니라 **저장을 하여 사용한다는 것이 특징**이다

<br/>

초기 배열은 모두 0값으로 초기화를 하고, 처음 부터 계산을 하며 저장을 하는 방식이다. 

이렇게 되면 만약 f[10]을 구할 때 f[9]와 f[8]이 필요하고, 이 값들은 이미 아래서부터 계산이 되어 저장을 시키며 올라왔기 때문에 그냥 가져오면 된다

즉, **재귀는 O(2^n)** 이 걸리지만. 배열을 사용하면 **처음 연산 이후** 값을 가져오는데 **O(1)** 이 걸리기 때문에 훨씬 효율적이다 

<br/>

## 동적 프로그래밍 적용 성질 

동적 프로그래밍을 적용하는 문제는 아래와 같은 두 성질이 있다 

- 최적 부분 구조 :  큰 문제의 최적 솔루션에 **작은 문제의 최적 솔루션이 포함**, 즉 하위 레벨로 갔을 때 **해답이 존재해야 함**

- 중복되는 부분 문제 : 재귀적 해법으로 풀면 같은 문제에 대한 **재귀호출이 심하게 중복되는** 문제 

<br/>

## 동적 프로그래밍 예시 

재귀 호출을 활용한 동적 프로그래밍 예시는 아래와 같다 

![image](https://github.com/user-attachments/assets/0267ecc7-742f-4e6c-86a0-9e03b9463a29)

- 재귀 호출을 사용하지만, 미리 계산한 값이 있는지 확인하여 중복 연산을 피함

- 이러한 방식도 동적 프로그래밍의 일종

<br/>

이와 같은 방식을 **하향식(Top-down)** 방식이라고하며, 앞서 다룬 것과 같이 i=1부터 계산하면서 올라가는 방식은 **상향식(Bottom-up)** 방식이라 함

상향식이 더 자주 활용되나 둘 다 동적 프로그래밍의 범주에 속한다 

<br/>

## 행렬 경로 문제 

문제 상황 : 양수 원소들로 구성된 n×n 행렬이 주어지고, 행렬의 좌상단에서 시작하여 우하단까지 이동하는 상황을 가정한 문제

**이동 방법 (제약조건)**

- 오른쪽이나 아래쪽으로만 이동할 수 있다

- 왼쪽, 위쪽, 대각선 이동은 허용하지 않는다

<br/>

**목표**

행렬의 좌상단에서 시작하여 우하단까지 이동하되, 방문한 칸에 있는 수들을 더한 값이 최대화되도록 한다

![image](https://github.com/user-attachments/assets/1a96ffb7-ea46-4ed0-ab49-a12945da1060)

<br/>

**행렬 경로 문제 코드**

![image](https://github.com/user-attachments/assets/17a0d789-e040-4240-baff-a9533ceb1c9c)

- m[i][j] : 행렬의 각 칸에 있는 숫자

- c[i][j] : (1,1)에서 시작해서 (i,j)에 도달할 수 있는 최대 점수

- 점수는 이동 경로 중 방문한 칸의 수를 누적해서 계산함

<br/>

위 문제가 동적 프로그래밍과 관련이 있는 이유는 **재귀함수**로 되어있고, 점차적으로 **최적의 해답으로** 향하기 때문이다

처음 a칸 -> b칸 -> ..  -> k칸으로 이동할 때, 각 칸의 수가 누적이 된 채로 다음 칸을 계산한다 

이 방식은 피보나치와 유사하며 동적 프로그래밍으로 접근할 수 있다. 

<br/>

추가적으로, 최적 부분 구조에서 더 작은 문제의 **최적의 해답**을 찾는 것이였는데 피보나치는 경로가 일정하고 규칙적이여서 단 하나만 존재하였다. 

그래서 그 경로가 결국 최적의 해가 된 것인데 

행렬 경로 문제는 다양하게 접근할 수 있고, 최종적으로 도달했을 때 각 경로마다 결과가 다를 수 있으므로 이 중 최적의 해를 구해야 한다 

<br/>

**행렬 경로 문제 코드 결과**

![IMG_3153](https://github.com/user-attachments/assets/3b4579ef-d462-4222-a270-ff998ac73347)

이렇게 코드를 만들면, 시간복잡도가 **O(2^(n+m))** 이 소요돼서 너무 오래 걸린다 (n x m 행렬)

<br/>

## 행렬 경로 문제 & DP

위에서 행렬 경로 문제를 아래와 같이 DP로 코드를 작성하면 결국 행렬의 모든 칸을 검사히기 때문에 **Θ(𝑛2)** 의 시간 복잡도를 가지며 행렬의 총 원소 수에 대해서 선형 시간으로 볼 수 있다 

```ruby
matrixPath(n) 
▷(n, n)에 이르는 최고점수 
{ 

for i ← 0 to n
    c[i, 0] ← 0; 

for j ← 1 to n
    c[0, j] ← 0; 

for i ← 1 to n
    for j ← 1 to n
       c[i, j] ← mij + max(c[i-1,  j], c[i,  j-1]); 

return c[n, n]; 
}
```

![IMG_3154](https://github.com/user-attachments/assets/597139cf-2094-4810-8f7b-c986807dc827)

<br/>

## 돌 놓기 문제

돌 놓기 문제는 3 × 𝑛 행렬의 각 칸에 양 또는 음의 정수가 기록되어 있으며, 해당 행렬에 돌을 놓는 상황이다

돌을 놓을 때의 제약조건은 다음과 같다 

- 가로나 세로로 인접한 두 칸에 동시에 조약돌을 놓을 수 없다

- 각 열에는 적어도 하나 이상의 조약돌을 놓는다

<br/>

목표: 돌이 놓인 자리에 있는 수들의 **합이 최대**가 되도록 돌 놓기

![image](https://github.com/user-attachments/assets/5b6f6baa-6136-466d-96ef-ff771c0dab51)

<br/>

**예시**

![image](https://github.com/user-attachments/assets/544b23da-bd9d-42fa-927f-c45011eea3ed)

<br/>

돌 놓기 문제에서 임의의 열을 채울 수 있는 패턴은 아래와 같이 4가지가 존재한다 

![image](https://github.com/user-attachments/assets/67c26a6c-21ed-4440-807f-cda42660562f)

<br/>

패턴별로 서로 인접한 열에서 양립할 수 있는 패턴들을 정리해보면 아래와 같다 

직사각형 아래에 표시된 숫자가 패턴의 번호이다 

![image](https://github.com/user-attachments/assets/65121e32-3250-4bfb-9e7e-d1d35350c578)

즉, i = 1번째인 열부터 시작하여(처음 시작하는 열) 다음 열로 갈 때 만약 내가 현재 열의 맨 위에다가 돌을 두고 싶다면(패턴이 1인 경우), 이전 패턴이 2 또는 3이여햐만 하고, 이때 최대 합을 구하여 비교하는 방식으로 코드를 작성할 수 있다 

아래 최적 부분 구조와 재귀 알고리즘을 살펴보자 

## 최적 부분 구조 확인 

![image](https://github.com/user-attachments/assets/db6ff4d9-5937-4e29-9462-edaa268a746c)

개념 복습을 하자면, 위 공식이 최적 부분 구조를 확인하는 공식인 이유는 전체 문제의 최적해가, **그 하위 문제들의 최적해**로 구성할 수 있는지 확인하는 공식이다 

i열까지의 최적 점수(c[i][p])를 구하려면, 반드시 i-1열까지의 최적 점수(c[i-1][q])들 중 하나를 선택해야 한다

다시 말해, **작은 문제(i-1열까지의 최적 점수)** 가 있어야 큰 문제(i열까지의 최적 점수)를 구할 수 있는데, 이는 딱 **최적 부분 구조**의 정의에 부합하기 때문이다

<br/>

## 재귀 알고리즘 (DP x)
```ruby
pebble(i, p)
▷i열이 패턴 p로 놓일 때의 i열까지의 최대 점수 합 구하기
▷w[i, p] : i 열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수 합.  p = {1, 2, 3, 4}
{
    if (i == 1)
        return w[1, p];
    else {
        max ← -∞;  ▷ 초기 max값을 그냥 작은 수로 놓겠다는 의미

        for q ← 1 to 4 {
            if (패턴 q가 패턴 p와 양립) {    ▷ 현재 패턴이 이전 패턴과 서로 조건이 맞다면 if문 통과, 즉 양립하는 모든 패턴을 검사함
                tmp ← pebble(i - 1, q);      ▷재귀 실행 -> 답을 구하고 다음 코드로 넘어감 
                if (tmp > max)
                    max ← tmp; 
            }
        }

        return (max + w[i, p]);              ▷ 현재 노드 + 이전 패턴의 최대 값
    }
}

pebbleSum(n)
 ▷n 열까지 조약돌을 놓은 방법 중 최대 점수 합 구하기
{
     return max { pebble(n, p) } ;
 }

 ▷ p =1,2,3,4
 ▷ pebble(i, 1), …, pebble(i, 4) 중 최대값이 최종적인 답
```

<br/>

위 코드의 재귀 함수는 다음과 같이 진행된다 

재귀 함수가 내려오다 i=1이 되면 해당 노드의 값을 반환한다 (by if (i == 1) -> return w[1, p];)

만약 처음 시작할 때 돌을 **(1,1)**에 놓는다면, 다음 열에는 **(2,2)와 (2,3**에 놓을 수 있다

즉, 여기서 for문의 if문이 성립이 된다 

그럼 (2,3)에 상황을 예시로 들겠다. 상황은 아래와 같다 

```ruby
pebble(2, 3) → pebble(1, 1) 호출 → w[1][1] 반환
```

<br/>

위 코드의 pebble(2,3)은 다음과 같이 계산이 된다 

```ruby
max = w[1][1]   ← 이전 결과
pebble(2, 3) = max + w[2][3]  ← 자기 열의 점수 더함
```

위의 과정과 같이 for문은 1~4의 패턴을 모두 확인하며, 가능한 패턴을 모두 검사하여 **최종 max을 도출**하는 방식이다 

이것을 일반화하면 아래와 같다 

<br/>

![image](https://github.com/user-attachments/assets/79a42e43-a92a-42cd-971c-1ec994af934f)

<br/>

## 돌 놓기 문제 & 재귀 결과 

![image](https://github.com/user-attachments/assets/4e42825c-e488-45ca-8362-9b0f3160889e)

돌 놓기 문제에서 재귀를 사용했을 때 다음과 같이 막대한 양의 반복 연산을 진행해야 한다 

이것을 DP 알고리즘을 통해 해결하면 아래와 같다 

<br/>

## 돌 놓기 문제 & DP 

돌 놓기 문제를 DP를 활용하여 다음과 같이 풀 수 있다 

```ruby
pebble(n)
{
    for p ← 1 to 4
        peb[1][p] ← w[1][p];    ▷ peb 배열에 저장하며 불러오는 형식 

    for i ← 2 to n
        for p ← 1 to 4
            peb[i][p] ← max { peb[i-1][q] } + w[i][p];
                        // 단, q는 p와 양립하는 패턴

    return max { peb[n][p] } ;  // p = 1, 2, 3, 4
}
```

<br/>

## 돌 놓기 문제 & DP 시간복잡도 

![image](https://github.com/user-attachments/assets/a4235526-43ad-423f-a899-63104659ee85)

주어진 코드는 배열에 저장을 하며 올라가는 방식이기 때문에, 배열에서 불러오는 시간은 상수 시간이 걸린다. 

따라서 시간복잡도는 **Θ(n)** 만큼 소요된다

<br/>

## 퀴즈 

![image](https://github.com/user-attachments/assets/6a8b4263-2249-47d0-8148-3e7ad792490c)

![IMG_3161](https://github.com/user-attachments/assets/ea807a96-f3ae-4d84-9a5e-e766f713db50)

위 공식을 참고하여 D(4)를 구해보면, D(4) = D(3) + D(2)이고, 이것은 아래와 같이 진행된다 

![image](https://github.com/user-attachments/assets/1153c238-1a06-47b8-88b7-9630b564f538)

<br/>

D(3)는 처음에 구한 D(1) + D(2)로 구할 수 있고, 이것을 이용하여 base case D(1)과 D(2)가 **초기 2칸의 모든 경우의 수** 이기 때문에

n = 4일 때 **n = 3일 때와 n = 2일 때로 분류** 하는 것이다. (n = 3일 때 남는 공간은 1이고 이것은 D(1), n = 2일 때 남는 공간은 2이고 이것은 D(2))

n = 3일때는 이전 차례에서 구해왔기 때문에 계속 i번째의 경우의 수는 **i-1번째의 모든 경우의 수 + i-2번째의 모든 경우의 수**로 구할 수 있다

따라서 점화식은 **D(n) = D(n-1) + D(n-2)** 이다

<br/>

이 문제가 전하고자 하는 바는 **n을 작게 쪼갠 뒤 모든 경우를 생각**하는 것이다

즉, 첫번째로 n을 작게 쪼개어 가능한 모든 경우를 생각하고, 이것을 다음 단계에서 어떻게 활용할 지를 고민하며 식을 만들어 가는 것이 규칙을 찾는 공식이다

<br/>

## 도미노 & DP 알고리즘 

다음은 위 문제를 DP 알고리즘으로 표현한 코드이다 

```ruby
def domino_tiling(n):
    # Base cases
    if n == 1:
        return 1
    if n == 2:
        return 2

    # DP 배열 생성 (0부터 n까지, 총 n+1개)
    dp = [0] * (n + 1)            ▷ D(1)부터 시작하기 때문에 n개를 만들어 버리면 총 n-1개만 사용 가능함
    dp[1] = 1  # D(1)
    dp[2] = 2  # D(2)

    # 점화식 적용: D(n) = D(n-1) + D(n-2)
    for i in range(3, n + 1):            ▷ base case에서 D(1)과 D(2)를 정의했기 때문에, for문은  i = 3 부터 시작 
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```













































