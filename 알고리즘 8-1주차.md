## 동적 프로그래밍

**동적 프로그래밍** : 큰 문제의 해답에 **더 작은 문제의 해답**이 포함되어 있으며, 이를 재귀호출로 구현할 때 같은 해답을 구하기 위한 중복 호출이 다수 발생하는 경우에 활용하는 문제해결 기법

동적 프로그래밍의 목적은 재귀를 사용했을 때 같은 연산을 반복해야하는 비효율적인 연산을 해결하기 위해 **계산된 값을 메모리에 저장해** 두 번 다시 계산하지 않기 위함이다 

큰 문제의 해답에 **더 작은 문제의 해답**이 포함된 경우를 **최적 부분 구조(Optimal Substructure)** 를 가진다고 한다

<br/>

최적 부분 구조를 피보나치 수열로 예를 들면, fib(5) = fib(4) + fib(3)으로 나눠질 때, fib(4)와 fib(3)를 구하려면 더 내려가야하고 fib(2) 또는 fib(1)에 도달했을 때 값을 구하는 구조를 의미한다 

중요한 것은 식을 쪼갠 다음에 각각 **작은 문제의 최적 답**만 잘 모으면 해답이 존재하는 것이 최적 부분 구조이다

<br/>

**피보나치 예시**

![image](https://github.com/user-attachments/assets/5b8af235-fc63-454e-90de-3b32b803d994)

위 코드에서 fib(7)만 실행해도 아래와 같이 fib(2)가 8번이나 반복 연산을 해야하고 n값이 증가할수록 반복 연산의 수가 기하급수적으로 커진다 

![image](https://github.com/user-attachments/assets/8afaf7f2-5c45-494c-a2fc-81c0aecd1a13)

위와 같은 반복 연산의 문제를 **동적 프로그래밍을 통해 해결할 수 있다**

<br/>

## 피보나치 & 동적 프로그래밍

피보나치를 **f라는 배열을 이용하여** 동적 프로그래밍을 해결한 코드를 보자 

![image](https://github.com/user-attachments/assets/24408eed-5592-4730-870e-2a4a743e28c0)

위 코드와 같이 동적 프로그래밍은 재귀가 아니라 **저장을 하여 사용한다는 것이 특징**이다

<br/>

초기 배열은 모두 0값으로 초기화를 하고, 처음 부터 계산을 하며 저장을 하는 방식이다. 

이렇게 되면 만약 f[10]을 구할 때 f[9]와 f[8]이 필요하고, 이 값들은 이미 아래서부터 계산이 되어 저장을 시키며 올라왔기 때문에 그냥 가져오면 된다

즉, **재귀는 O(2^n)** 이 걸리지만. 배열을 사용하면 **처음 연산 이후** 값을 가져오는데 **O(1)** 이 걸리기 때문에 훨씬 효율적이다 

<br/>

## 동적 프로그래밍 적용 성질 

동적 프로그래밍을 적용하는 문제는 아래와 같은 두 성질이 있다 

- 최적 부분 구조 :  큰 문제의 최적 솔루션에 **작은 문제의 최적 솔루션이 포함**, 즉 하위 레벨로 갔을 때 **해답이 존재해야 함**

- 중복되는 부분 문제 : 재귀적 해법으로 풀면 같은 문제에 대한 **재귀호출이 심하게 중복되는** 문제 

<br/>

## 동적 프로그래밍 예시 

재귀 호출을 활용한 동적 프로그래밍 예시는 아래와 같다 

![image](https://github.com/user-attachments/assets/0267ecc7-742f-4e6c-86a0-9e03b9463a29)

- 재귀 호출을 사용하지만, 미리 계산한 값이 있는지 확인하여 중복 연산을 피함

- 이러한 방식도 동적 프로그래밍의 일종

<br/>

이와 같은 방식을 **하향식(Top-down)** 방식이라고하며, 앞서 다룬 것과 같이 i=1부터 계산하면서 올라가는 방식은 **상향식(Bottom-up)** 방식이라 함

상향식이 더 자주 활용되나 둘 다 동적 프로그래밍의 범주에 속한다 



















