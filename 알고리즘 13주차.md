## 벨만-포드 알고리즘

**벨만-포드 알고리즘** : **음의 가중치**가 있는 그래프에서도 사용 가능한 **최단 경로 알고리즘**

**시간 복잡도 : Θ(|V| x |E|)**   

```ruby
BellmanFord(G, r)  // G는 그래프, r은 시작 정점
{
    for each u ∈ V              // 모든 정점 u에 대해
        d[u] ← ∞;               // 거리 값을 무한대로 초기화
    d[r] ← 0;                   // 시작 정점 r의 거리는 0으로 설정

    for i ← 1 to |V| - 1        // 정점 수 - 1번 반복 (최악의 경우 모든 간선을 이완)
        for each (u, v) ∈ E     // 모든 간선 (u, v)에 대해
            if (d[u] + w[u, v] < d[v]) then { // u를 거쳐 v로 가는 경로가 더 짧다면
                d[v] ← d[u] + w[u, v];        // 거리 값을 갱신 (이완: relaxation)
                prev[v] ← u;                  // 최단 경로 상 이전 정점을 기록
            }

    // 음의 사이클 존재 여부 확인
    for each (u, v) ∈ E
        if (d[u] + w[u, v] < d[v])  // 여전히 더 짧은 경로가 있다면
            output "해없음";       // 음의 사이클 존재함

   
}
```

알고리즘은 위와 같이 그래프 내의 각 간선들에 대해서 거리값을 이완시켜주는 작업을 **|V|-1번** 반복한다 

그래프 자체에서는 싸이클이 존재할 수 있지만, 벨만-포드 알고리즘을 이용하여 최단 경로를 찾을 때 **|V|-1번**만 검사해도 경로를 만들 수 있다 

**예시**

```ruby
A → B → C → D (최단 경로: 4)

그런데 C에서 E로 갔다가 C로 다시 오는 사이클이 있다고 하자
C → E → C (가중치 합 = 0)

A → B → C → E → C → D 는 가중치가 같거나 더 클 뿐, 쓸데없는 경로이기 때문에 싸이클을 제외하기 위해 |V|-1개의 간선만을 탐색한다
```























































































   
