## 벨만-포드 알고리즘

**벨만-포드 알고리즘** : **음의 가중치**가 있는 그래프에서도 사용 가능한 **최단 경로 알고리즘**

**시간 복잡도 : Θ(|V| x |E|)**   

```ruby
BellmanFord(G, r)  // G는 그래프, r은 시작 정점
{
    for each u ∈ V              // 모든 정점 u에 대해
        d[u] ← ∞;               // 거리 값을 무한대로 초기화
    d[r] ← 0;                   // 시작 정점 r의 거리는 0으로 설정

    for i ← 1 to |V| - 1        // 정점 수 - 1번 반복 (최악의 경우 모든 간선을 이완)
        for each (u, v) ∈ E     // 모든 간선 (u, v)에 대해
            if (d[u] + w[u, v] < d[v]) then { // u를 거쳐 v로 가는 경로가 더 짧다면
                d[v] ← d[u] + w[u, v];        // 거리 값을 갱신 (이완: relaxation)
                prev[v] ← u;                  // 최단 경로 상 이전 정점을 기록
            }

    // 음의 사이클 존재 여부 확인
    for each (u, v) ∈ E
        if (d[u] + w[u, v] < d[v])  // 여전히 더 짧은 경로가 있다면
            output "해없음";       // 음의 사이클 존재함

   
}
```

알고리즘은 위와 같이 그래프 내의 각 간선들에 대해서 거리값을 이완시켜주는 작업을 **|V|-1번** 반복한다 

그래프 자체에서는 싸이클이 존재할 수 있지만, 벨만-포드 알고리즘을 이용하여 최단 경로를 찾을 때 **|V|-1번**만 검사해도 경로를 만들 수 있다 

주의해야할 점은 반복을 |V|-1번을 한다는 것이지 **검사하는 간선은 모두 검사한다** (즉, 모든 간선을 검사하기 때문에 |V|개 이상 검사할 수 있다)

<br/>

## 만약 |V|개를 탐색한다면?

만약 |V|개 이상의 간선으로 이루어진 최단 경로가 존재한다면 경로 상에 **반드시 하나 이상의 사이클이 존재할 것이다**

이 경우, 최단 경로 문제에서 사이클에서의 가중치 합은 음이 될 수 없으므로 (음의 무한대로 향해서 답을 구할 수 없음) 반드시 0 이상이여야 한다

그러나  만약 사이클에서의 가중치 합이 0 초과라면 사이클을 제외하여 경로 전체의 가중치 합을 낮출 수 있으므로 **최단 경로라는 가정을 위배하게 된다**

가중치 합이 0이어도 사이클을 제외하여 더 적은 수의 간선으로 최단 경로를 만들 수 있어서 **오류가 발생한다**

**예시**

```ruby
A → B → C → D (최단 경로: 4)

그런데 C에서 E로 갔다가 C로 다시 오는 사이클이 있다고 하자
C → E → C (가중치 합 = 0)

A → B → C → E → C → D 는 가중치가 같거나 더 클 뿐, 쓸데없는 경로이기 때문에 싸이클을 제외하기 위해 |V|-1개의 간선만을 탐색한다
```

<br/>

## 벨만 포드 & 다익스트라 알고리즘 차이점

아래 정점 A에서 시작하는 그래프가 있다고 생각해보자 

![image](https://github.com/user-attachments/assets/62043019-16ae-4604-a9b1-3d64791824ee)

위 그래프를 다익스트라 알고리즘을 이용하여 최단 경로를 구한다면

1. A 집합 최단 경로 -> 정점 B : (A,B) 집합 생성

2. (A,B) 집합 최단 경로 -> 정점 C : (A,B,C) 집합 생성

3. (A,B,C) 집합 최단 경로 -> 정점 E : (A,B,C,D) 집합 완성

이렇게 구할 수 있다 

<br/>

**하지만 직관적으로 그래프를 보면** D를 거치고 C로 가는 비용은 3이기 때문에 **이 경로가 더 빠르다**

<br/>

### 다익스트라 문제점는 다음과 같다 

<br/>

**다익스트라 알고리즘**은 **현재까지 발견된 최단 경로**를 기반으로 작동한다 

최단 경로라고 판단하면 집합으로 묶은 후 **포함된 정점 사이의 거리는 계산을 하지 않는다**

즉, **한 번 최단으로 판단된 경로**는 그 이후에 **변경되지 않아서 더 짧은 경로를 찾을 수 없다는 것**이 다익스트라 알고리즘의 문제점이다

<br/>

### 하지만 벨만-포드는 모든 정점을 탐색하여 이러한 문제를 해결할 수 있다

벨만-포드 알고리즘의 코드를 보면 **모든 턴마다 모든 간선의 수를 비교**한다

따라서 **시간이 좀 걸리지만 최단 경로를 확실하게 구할 수 있다**는 장점이 있다

<br/>

## 벨만-포드 알고리즘 예시

![IMG_3321](https://github.com/user-attachments/assets/ed313a8a-f566-4834-a20f-b66e4f61a451)

![IMG_3320](https://github.com/user-attachments/assets/21893be7-8116-4973-83d1-7d749d939786)


만약 음의 사이클을 갖는 그래프에서 벨만-포드 알고리즘을 적용하고 나면 최단 경로에 해당하는 간선들이 prev로 저장된 것이 아니라, 음의 사이클이 prev로 저장되는 결과가 나옴

이것은 벨만-포드는 알고리즘 마지막 단계에서 음의 사이클이 있는지 여부를 확인하는 절차가 포함되어 있어 이를 검출할 수 있다 

음의 가중치가 없고, 다익스트라 알고리즘이 사용 가능한 경우에도 벨만-포드를 대신 사용할 수는 있지만, **시간이 더 오래 걸리므로 비효율적**이다

<br/>

## 음의 사이클을 갖을 때 예시 

![image](https://github.com/user-attachments/assets/7f711b6e-2275-4423-bc48-7328a17431e2)

<br/>

## 플로이드-워샬 알고리즘

**플로이드-워샬 알고리즘** 

- **동적 프로그래밍을 이용하여** 모든 정점 쌍에서의 **최단 경로를 구함**

- **음의 가중치를 허용함**

- 최적 부분구조를 표현하기 위해 최단 경로에 포함될 수 있는 **정점 집합의 크기를 문제 크기로 설정**함

<br/>

**개념 정리**

- 다익스트라 : 한 출발점 기준 최단경로

- 벨만-포드 : 음수 가중치 포함한 단일 출발점

- 플로이드-워샬 : 전체 정점 쌍의 최단 거리를 한 번에 계산 (모든 쌍 최단 경로)

<br/>

![IMG_3330](https://github.com/user-attachments/assets/526df48a-5dc3-438c-be3b-e13082ae2cf6)

<br/>

## 플로이드-워샬 과정 예시 1

![IMG_3327](https://github.com/user-attachments/assets/eaf64e8a-a023-49ff-84af-45de15272e51)

![IMG_3328](https://github.com/user-attachments/assets/d89ef156-f8f4-4370-a4d1-7479a084ddcc)

![IMG_3324](https://github.com/user-attachments/assets/0069e337-232d-4a18-8ae1-9bba0f878ace)

![IMG_3325](https://github.com/user-attachments/assets/408914b9-4e62-4e8c-a25c-d70a40741ea1)

![IMG_3326](https://github.com/user-attachments/assets/0fd2fb34-dada-4f43-8b4b-6624dda6b82d)

<br/>

## 플로이드-워샬 과정 예시 2

![IMG_3331](https://github.com/user-attachments/assets/db78a756-5ce6-4089-b48d-469ed8fa0167)

![IMG_3332](https://github.com/user-attachments/assets/95e5b91a-3b91-4882-ba22-182e496042a2)

i에서 j까지의 최단 경로가정점 k를 지난다면 i에서 k까지의 최단 경로와 k에서 j까지의 최단 경로로 분할 가능함. 그리고 전체 경로가 k까지의 정점들만을 활용하므로 분할된 경로들은 k 도 제외된 k-1까지의 정점들만 활용한 경로에 해당함

i에서 j까지의 최단 경로가 정점 k를 지나지 않는다면 k-1까지의 정점을 활용한 경우에서 변경 사항이 없음

<br/>

## 플로이드-워샬 알고리즘

**시간 복잡도: Θ(|V|3)**

**문제의총 수 Θ(|V|3), 각 문제의 계산에 Θ(1)**

```ruby
FloydWarshall(G)                             ▷ 시작 상황: 입력으로 주어진 가중치 그래프 G = (V, E)가 있음
{
    for i ← 1 to n                           ▷ i: 시작 정점 (source vertex)
        for j ← 1 to n                       ▷ j: 도착 정점 (destination vertex)
            d^0_ij ← w_ij                    ▷ 초기 거리 설정: 정점 i에서 j로의 직접적인 가중치 (없으면 ∞)

    for k ← 1 to n                           ▷ k: 중간 정점 집합 {1, 2, ..., k}를 고려
        for i ← 1 to n                       ▷ i: 시작 정점
            for j ← 1 to n                   ▷ j: 도착 정점
                d^k_ij ← min( d^{k-1}_ij, d^{k-1}_ik + d^{k-1}_kj )
                                             ▷ i에서 j로 가는 경로 중 기존의 최단 거리와 k를 경유하는 경로의 거리 중 더 짧은 것을 선택
                                         
}
```

해당 알고리즘을 보면 k = 1일 때 부터(k=1일 때 정점 1을 거친다는 의미) 시작하여 i->j로 이동할 때 정점 1을 거쳐서 가는 거리와 거치지 않고 간 거리 중 짧은 값을 최단 거리로 선택한다 

그 후 k = 2 일때는 k = 1에서 구한 최단 경로를 이용하여 정점 1과 정점 2을 거쳤을 때의 최단 경로를 구하는 방식이다 

### 사이클이 없는 그래프의 최단 경로

```ruby
DAG-ShortestPath(G, r) 
{ 
    for each u ∈ V                          ▷ 모든 정점 u에 대해
        du ← ∞;                              ▷ 모든 정점까지의 거리 초기화
    dr ← 0;                                  ▷ 시작점 r까지 거리는 0으로 설정
    G의 정점들을 위상정렬한다;                ▷ 정점들을 사이클 없도록 순서대로 정렬

    for each u ∈ V (위상정렬 순서로)
        for each v ∈ L(u)                      ▷ L(u) : 정점 u로부터 연결된 정점들의 집합
            if (du + w(u,v) < dv ) then {       ▷ u를 거쳐가는 경로가 더 짧다면
                    dv ← du + wu,v ;            ▷ 최단 거리 업데이트
                    prev[v] ← u                 ▷ 이것을 prev 리스트에 저장 
            }
 } 
```













































   
