## 프림 알고리즘 

**프림 알고리즘** : MST(최소 신장 트리)를 구하는 알고리즘의 일종이며, 첫 정점을 시작으로 가장 가까운 이웃들을 추가해나가며 만들어 나간다

![스크린샷 2025-05-18 111842](https://github.com/user-attachments/assets/f81f585e-4d14-4ec2-b1f9-e2838c3b22ec)

![스크린샷 2025-05-18 111855](https://github.com/user-attachments/assets/f699d4a2-bc16-48c0-995f-18f1f9863e89)

![스크린샷 2025-05-18 111904](https://github.com/user-attachments/assets/0401144b-db32-4f78-babe-36db707e83d8)

![스크린샷 2025-05-18 111916](https://github.com/user-attachments/assets/02ed4890-52df-4292-bf99-f1d727bd7863)

<br/>

**프림 알고리즘**

```ruby
Prim (G, r)
{   
    S ←Ф;
    정점 r을 방문되었다고 표시하고, 집합 S에 포함시킨다;
    while (S≠V) {
           S에서 V-S를 연결하는 간선들 중 최소길이의 간선 (x, y) 를 찾는다; ▷(x∈S, y∈V-S)
           정점 y를 방문되었다고 표시하고, 집합 S에 포함시킨다;
    }
}
```

<br/>

## 프림 알고리즘 구현 

```ruby
Prim(G, r)
▷ G=(V, E): 주어진 그래프
▷ r: 시작으로 삼을 정점
{
    S ← ∅                           ▷ S : MST에 포함된 정점들의 집합
    for each u ∈ V                  ▷ V : 전체 노드 집합 
        dₓ ← ∞ ;                     ▷ 시작 정점을 제외한 모든 정점의 거리를 임의의 큰 수로 초기화
    dᵣ ← 0 ;                         ▷ 시작 정점은 0으로 초기화
    
    while (S ≠ V) {                  ▷ n회 순환 (모든 정점이 MST에 포함되지 않을 때까지 반복)     
        u ← extractMin(V - S, d);
        S ← S ∪ {u};
        
        for each v ∈ L(u)           ▷ L(u) : u로부터 연결된 정점들의 집합
            if (v ∈ V - S and wᵤᵥ < dᵥ) then dᵥ ← wᵤᵥ;          ▷ v ∈ V - S : v가 아직 MST 집합 S에 포함되지 않은 정점, 
    }                                                            ▷ wᵤᵥ < dᵥ u에서 v로 가는 간선의 가중치가 v로의 최소 거리보다 작은지 비교 
}

extractMin(Q, d)
{
    ▷ 집합 Q에서 d값이 가장 작은 정점 u를 리턴한다;
}
```

프림 알고리즘에서 거리 계산의 기준은 r과의 거리를 잰다 

![image](https://github.com/user-attachments/assets/fd54525b-fc02-4e4d-a689-226877c9f659)

위 예시로 설명하자면, 시작점을 A라고 했을 때 A와 연결되어 있는 B와 C중 **거리가 가장 짧은** A → C (3)을 선택한다 (이것이 while문의 첫번째 코드와 두번째 코드)

이후 while문의 for문의 주석을 보면 u로부터 연결된 정점의 집합이라고 되어있는데 u는 a로부터 거리가 가장 짧은 c가 될 것이고 

if문을 통해 S 집합에 (MST에 포함된 정점들의 집합) 포함되지 않는 요소들 중에서 (정점 A와 C제외) C와 연결된 정점인 B, D, E과의 거리를 계산한다 

<br/>

또한, if문을 보면 위 예시에서 W(u,v)는 C와 연결된 정점의 거리를 의미하고 dv는 시작점인 r과 해당 노드의 거리를 의미힌다 

즉, r에서 해당 노드로 가는 것보다 **C를 거쳐 갔음에도 이 거리가 더 짧다면**, C를 거쳐가 간 거리를 **최소 길이로 정하기 위함**이다 

<br/>

## 프림 알고리즘 시간 복잡도 

**프림 알고리즘 시간 복잡도 : O(|E|log|V|)**

<br/>

**시간복잡도 풀이 과정**

Prim 알고리즘의 주요 연산은 두 가지로 나눌 수 있다

- 정점 선택 (extractMin)

- 간선 업데이트 (Relaxation)

<br/>

**step 1 : 정점 선택 (extractMin)**

Prim 알고리즘에서는 가장 작은 비용의 간선을 찾기 위해 **우선순위 큐(Heap)** 를 사용한다 

이 과정에서 매번 extractMin 연산이 일어난다

Heap 자료구조에서 최소값을 찾는 연산은 **O(log V)**의 시간 복잡도가 걸리고 모든 정점을 순회하기 때문에, V번 실행

따라서, 이 단계의 시간 복잡도는 O(V⋅logV)이다 

<br/>

**step 2 : 간선 업데이트 (Relaxation)**

Prim 알고리즘의 매 단계에서 현재 선택된 정점과 연결된 모든 간선을 탐색한다 

간선의 개수는 최대로 E개가 될 수 있다

각각의 간선 탐색에서 우선순위 큐를 업데이트하면, 시간복잡도는 O(E⋅logV)이다 

<br/>

**step 3 : 최종 계산**

일반적으로 **간선의 수(E)** 가 **정점의 수(V)** 보다 많으므로

O(VlogV) + O(ElogV) ≈ **O(ElogV)** 이다

<br/>

## 크루스칼 알고리즘 

**크루스칼 알고리즘** : 프림 알고리즘과는 다르게 트리 하나를 키워가는 방식이 아니라 노드 하나로 구성된 n개의 트리에서 점점 합쳐나가며 최종적으로 MST를 만드는 방식

1. 간선의 가중치를 오름차순으로 정렬한다

2. 정렬된 간선 중에서 순서대로(가중치가 낮은 순으로) 간선을 조회한다. 간선을 선택하게 될 때, 사이클이 형성된다면 다음 간선으로 넘어가고, 사이클이 형성되지 않는다면 해당 간선을 선택한다

3. 정점의 개수가 N일때, N-1만큼 간선을 뽑았다면 반복문을 종료한다

![스크린샷 2025-05-18 123042](https://github.com/user-attachments/assets/97add176-0c84-41c8-a27d-0acc8eb6ca85)

![스크린샷 2025-05-18 123057](https://github.com/user-attachments/assets/9fe9c485-f940-4b65-95ed-8410a81701d8)

![스크린샷 2025-05-18 123103](https://github.com/user-attachments/assets/757ed08c-6e00-463d-9805-bf16069b83ed)

![스크린샷 2025-05-18 123110](https://github.com/user-attachments/assets/4d3878bd-7516-427b-84af-d92d8d380580)

![스크린샷 2025-05-18 123122](https://github.com/user-attachments/assets/99964fde-94d3-4744-b9c1-e9e6b8559bc4)

<br/>

**크루스칼 알고리즘**
```ruby
Kruskal (G, r)
{
1. T ← Ф ; ▷ T: 신장트리 
2. 단 하나의 정점만으로 이루어진 n 개의 집합을 초기화한다;
3. 간선집합 Q(=E)를 가중치가 작은 순으로 정렬한다;
4. while (T의 간선수 < n-1) {
        Q에서 최소비용 간선 (u, v)를 제거한다;
        정점 u와 정점 v가 서로 다른 집합에 속하면 {
              두 집합을 하나로 합친다;
               T ← T∪{(u, v)};
        }      
 }
```































































































