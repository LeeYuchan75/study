## 트리 시간복잡도 비교 

![image](https://github.com/user-attachments/assets/eaaf9974-d4fb-4954-9154-08d238a70f4c)

위 표에서 B트리의 설명 중 'Balanced binary search tree보다 상수 인자가 작다'라는 말은 

B-트리는 한 단계에 수십~수백 개 자식 가능하여 탐색 시간이 이진 트리보다 빠르다는 의미이다 

빠르다는 말은 이진 트리보다 상수 시간이 작아서 시간 복잡도는 같으나 실제 성능은 B트리가 좀 더 좋다는 뜻임 

<br/>

## 해시 테이블 

**해시 테이블 : 원소가 저장될 자리가 원소의 값에 의해 결정되는 자료구조**

트리에서도 값에 의해 위치가 달라지는 것 같지만 그건 트리를 그렸을 때의 위치이며 메모리 상에서의 위치는 키 값에 따라 달라지는 것이 아님

즉, **트리의 위치는 메모리의 위치와 무관함**

<br/>

트리의 내부 구조를 예시로 표현하면 

```ruby
Node(10) → 주소 0xA1
Node(5)  → 주소 0xDE
Node(20) → 주소 0x73
```

단지 Node(10).left = 0xB7 이런 식으로 포인터로 연결되는 것뿐 메모리와는 무관함 

트리는 원하고자 하는 값을 찾은 뒤에 해당 메모리에 접근하는 것 

<br/>

반면에 **해시 테이블은 해당 값에 직접적으로 대응하는 주소에 저장됨**

따라서 **내가 찾고자 하는 값 입력하면, 바로 메모리에 접근할 수 있음**

<br/>

## 해시테이블 장단점 

장점 :  **탐색 속도가 매우 빠름 -> 평균 O(1)**

단점 : **정렬 불가, 최대 최소 찾는데 오래걸림**

<br/>

해시 테이블과 비교하여 트리는 구조를 구성하는데 해시 테이블보다 시간이 좀 더 소요되지만

이렇게 만들어 놓으면, **정렬도 편리하고, 최대 최소를 찾는데 유리하다**

추가적으로 해시 테이블은 애초에 최소 원소를 찾는 것과 같은 작업은 지원하지 않는다 

<br/>

## 정리 

![image](https://github.com/user-attachments/assets/c512f903-30f9-43c0-8696-f6b06ababca4)

<br/>

## 적재율 

적재율 : **해시 테이블에 원소가 차 있는 비율** -> 해시 테이블의 성능에 큰 영향을 끼침

적재율 = 사용중인 공간 / 전체공간

<br/>

## 해시 함수 

해시 함수 : 임의의 키 값을 입력받은 후 일정한 구간 내의 값(해시 테이블 상의 주소)으로 변환하는 함수

아래와 같은 두 가지 성질을 만족하여야 함

<br/>

1. 입력 원소가 해시 테이블 전체에 골고루 저장될 수 있도록 해야 함

2. 계산이 간단해야 함

<br/>

첫 번째 조건이 굉장히 중요하며, 만약 서로 다른 키 값들에 대해서 같은 주소값을 반환하게 되면 충돌이 발생하여 해시 테이블의 성능이 저하됨

<br/>

## 해시 함수 예시 

예시를 위해 단순하게  해시 테이블의 크기로 mod 연산을 수행

**ℎ(𝑥)=𝑥mod𝑚**

이 때, 일반적으로𝑚은 2의 멱수(2𝑝)에 가깝지 않은 소수로 설정함. 그 이유를 아래 예시를 통해 살펴보자 

<br/>

```ruby
            100              ← 몫 (100₂ = 4 in decimal)
       ---------
10000 ) 1000101
         10000               ← 1 × 10000 = 10000 (16)
         ------
          000101
           00000             ← 0 × 10000 = 00000
           ------
            00101            ← 나머지 (하위 비트)
```

위 예시와 같이 2의 제곱수는 이진수에서 k000..00 꼴이다

따라서 나눗셈을 할 때 더이상 나눠지지 않은 부분은 k이하인데 

이 말은 k이하의 부분이 동일하면 **같은 해시 값을 갖는다는 의미이고 즉, 충돌 위험성이 커진다는 의미이다**

그래서 일반적으로 2의 제곱수에 가까운 소수를 택함 -> 소수는 이러한 현상 덜해서 충돌 위험성도 줄여줌(충돌이 존재하긴 함)

<br/>

## 곱하기 방법 

## h(x)=⌊m⋅(x⋅Amod1)⌋

![image](https://github.com/user-attachments/assets/e5040a5e-1521-45c8-8d5a-085a0cc17c7e)

위에서 한 내용이 나누기 방법이라면 이번에 할 것은 곱하기 방법이다 

나누기 방법은 큰 수를 해시 테이블 크기 범위 내로 들어오도록 축소시키지만, 

곱하기 방법은 입력값을 0과 1 사이의 소수로 대응시킨 다음 𝑚을 곱하여 0과 𝑚−1사이로 팽창시킴

<br/>

**위 함수의 각 원소 설명**

- x : 입력값

- A: 0 < A < 1인 임의의 값 

- mod 1 : 소수 부분을 구하기 위함 -> 나누기는 빼기의 반복

- m : 소수 부분에 곱해줄 임의의 값

<br/>

## 곱하기 방법 장점 

**1. 충돌이 줄어든다**

**2. 균등하게 만들어줌**

𝑚값은 어떻게 잡아도 성능에 큰 영향이 없고, **𝐴값에 따라 해시 값 분포가 달라짐**

<br/>

## 예시 

해시 함수 : h(x)=⌊m⋅(x⋅Amod1)⌋

입력값 : x=123

테이블 크기 : m=16

상수 A=0.6180339887 (→ 황금비의 역수 ≈ 무작위성 좋음)

<br/>

**1. x 곱하기 A**

123⋅0.6180339887 = 76.0171806

<br/>

**2. 소수 부분만 추출**

76.0171806mod1 = 0.0171806

<br/>            

**3. m 곱하기 소수 부분**

16⋅0.0171806 = 0.2748896

<br/>

**4. 정수 부분만 취하기**

⌊0.2748896⌋ = 0

<br/>

## 충돌 

충돌 : 1해시 테이블의 한 주소를 놓고 두 개 이상의 원소가 자리를 다투는 것

충돌 해결 방법은 크게 두 가지가 있다

1. 체이닝(Chaining)

2. 개방주소 방법(Open Addressing)

<br/>

## 체이닝 

체이닝 기법 : 같은 해시값을 가지는 여러 데이터를 **연결 리스트로 이어서 저장하는 충돌 해결 방법**

체이닝 기법은 다음과 같은 특징을 갖는다 

**1. 해시 테이블 외에 추가적인 메모리가 필요함**

**2. 적재율이 1이 넘어가도 작동에는 문제 없음**

<br/>

여기서 **적재율이 1이 넘어가도 작동에 문제가 없다는 것은 효율적이라는 의미가 아니다**

이 경우 상수시간을 보장하지 않은 경우가 많음

<br/>

## 체이닝 알고리즘 

```ruby
chainedHashInsert(T[ ], x)
▷ T : 해시 테이블, x : 삽입 원소
{
    리스트 T[h(x)]의 맨 앞에 x를 삽입;     ▷ 해당 알고리즘은 맨 앞을 기준으로 함, 맨 뒤도 가능 
}

chainedHashSearch(T[ ], x)
▷ T : 해시 테이블, x : 검색 원소
{
    리스트 T[h(x)]에서 x값을 가지는 원소를 검색;
}

chainedHashDelete(T[ ], x)
▷ T : 해시 테이블, x : 삭제 원소
{
    리스트 T[h(x)]에서 x의 노드를 삭제;
}
```

만약 체이닝 기법을 연결 리스트가 아니라 배열로 구현한다면, 하나를 삭제할 때마다 모든 노드를 다 앞으로 옮겨야함 -> 복잡 + 번거로움

따라서 체이닝 기법은 연결리스트 사용 -> 관계로 구성되어 있기 때문에 다음 노드만 정해주면 됨 

<br/>

## 개방 주소 방법 

개방 주소 정의 : 충돌이 발생했을 때, **해시 테이블 내부의 다른 빈 칸을 직접 찾아가서 저장하는 방식**

개방 주소의 배경은 충돌이 일어나더라도 어떻게든 **주어진 테이블 공간 내에서 해결하기 위해 다른 해시값을 도출하는 것이다**

해시 테이블 외에 **추가적인 메모리가 필요하지 않음 -> 내부에서 해결하기 때문**

대표적으로 3가지 방법이 존재한다 

1. 선형 조사

2. 이차원 조사

3. 더블 해싱

<br/>

## 선형 조사

선형 조사 : **충돌이 발생하면 다음 칸으로 계속 이동하여** 빈 칸이 생기면 입력하는 방식

탐색할 때는 처음에 해시 값의 주소로 이동하여 찾고자 하는 값이 없으면 다음 칸을 찾는식으로 빈 칸이 나올때까지 탐색

빈 칸이 나올때까지 없다면 테이블 내에 해당 키 값은 없는 상태이다 

<br/>

## 선형 조사 예시 

![image](https://github.com/user-attachments/assets/5778530f-4fb7-4b90-afaf-8af17e5f9c3f)

위 함수에서 i는 처음 충돌이 발생하면 i=1 , 그 다음에도 발생하면 i=2로 위치값이 하나씩 올림

<br/>

## 선형 조사 문제점

선형 조사의 단점은 **특정 영역에 원소가 몰리는 1차 군집에 취약하다**

여기서 1차 군집이란, 특정 영역에 원소가 몰리는 현상을 의미한다

이 경우 검색을 할 때, O(n)의 시간이 소요될 수 있어서 상수 시간을 보장하지 못한다. -> 거의 안씀 

<br/>

이런 선형 조사를 해결하기 위해 나온 것이 이차원 조사이다 

<br/>

## 이차원 조사 

![image](https://github.com/user-attachments/assets/61d28634-9ab7-426b-bada-e17328f809e8)

선형 조사에서는 i의 값이 1씩 증가하였지만 이차원 조사에서는 i의 제곱이므로 

첫 충돌에는 위치가 +1 그 다음은 +4, 그 다음은 +9, ... + i^2 으로 기하급수적으로 옮김 -> 빠르게 처음 해시 영역을 벗어남 

<br/>

## 이차원 조사 문제점 

이차원 조사는 테이블 내의 인접 구간에 값들이 몰려있는 1차군집은 빠르게 벗어나지만

여러 키 값들이 동일한 초기 해시 함수값을 갖게되는 2차군집에는 취약함


- 1차 군집: 꼭 해시값이 같진 않더라도 인접한 영역에 몰리게 되는 경우

- 2차 군집: 초기 해시값이 같은 경우가 대량 발생

<br/>

즉, 2차 군집은 여러 개의 키가 같은 해시값을 가지는 경우, **이차원 조사의 특성상 탐색 경로가 완전히 똑같이 겹치면서** 특정 슬롯들에 충돌이 집중되는 현상

<br/>

## 더블 해싱

충돌이 발생할 때마다 **두 번째 해시 함수값을 이용해서 이동 거리를 결정하는 방식**

![image](https://github.com/user-attachments/assets/b4c6a83e-1a73-471f-af5a-a21bc6d38195)

<br/>

**함수 설명**

- h(x): 기본 해시 함수

- f(x): 두 번째 해시 함수

- i: 충돌 횟수

- m: 해시 테이블 크기

<br/>

**즉, 충돌할 때마다 f(x)만큼 떨어진 위치로 이동**

위 예시에서 h(𝑥) 에 대해 두 키 값의 해시 값이 같더라도 f(x) 에 대해서까지 해시 값이 같을 확률은 낮다

오른쪽 예시에서는 13과 11의 공배수인 키 값이 등장하면 선형 조사 방식으로 충돌을 해결하게 됨

f(x) 에서의 +1 항이 없으면 13과 11의 공배수에 대해선 충돌 해결 방법이 없음

![IMG_3098](https://github.com/user-attachments/assets/5cc4fca0-4b8e-4166-ab41-566b6bd4afe4)

<br/>

## 개방 주소 특징 

**개방 주소의 적재율은 절대 1을 넘을 수 없다** ->  테이블 안에만 데이터를 저장하기 때문에 적재율이 1(= 꽉 찼다)이 되면 더 이상 삽입 불가능

따라서 적재율이 1에 가까워지면 효율 급감한다 -> 테이블이 꽉 차기 직전에는 충돌도 많이 발생하고, 빈 칸 찾느라 탐색 시간이 오래 걸림

이 경우 **해결책은 테이블 크기를 2배로 늘리고, 모든 원소를 새롭게 해시테이블에 넣는 것이다**

<br/>

## 개방 주소 알고리즘 

```ruby
hashInsert(T[ ], x)
{
    i ← 0;
    repeat {
        j ← hᵢ(x);
        if (T[j] = NIL)
            then { T[j] ← x; return j; }
        else i++;
    } until (i = m)
    error "테이블 오버플로";
}

hashSearch(T[ ], x)
{
    i ← 0;
    repeat {
        j ← hᵢ(x);
        if (T[j] = x)
            then return j;
        else i++;
    } until (T[j] = NIL or i = m)
    return NIL;
}
```

<br/>

## 개방 주소 삭제 

개방 주소에서 원소를 삭제할 때는 **삭제된 칸이라는 표식(DELETED) 이 반드시 필요**

만약 어떤 값을 삭제했을 때, 남아 있는 값들은 그 자리에서 충돌이 생겨 넘어온 값일 수 있음 

삭제했을 때, 어떠한 표식도 안 해놓으면, 남아 있는 값을 찾기 위해 처음 충돌된 곳을 방문했을 때, 그냥 값이 없다고 나와버림 

따라서 delete(표식)을 해야 컴퓨터가 남아 있는 값들을 찾을 때, 안심하고 다음 값으로 넘어갈 수 있음 

<br/>

## 각 충돌 해결 방법의 장단점 

**이론적으로는 체이닝이 평균적으로 더 효율적이다**

개방주소 방법의 경우 직접적으로 충돌하지 않는 원소라도 검색 과정을 방해하기도 함

체이닝은 각 슬롯마다 연결 리스트를 사용하므로 충돌이 나더라도 다른 슬롯 탐색 없이 그 슬롯의 리스트만 보면 됨

개방 주소 기법은 충돌이 안 났던 데이터라도, 탐색 과정에서 무조건 훑게 됨

<br/>

하지만 **체이닝은 추가 저장공간(포인터 등)이 필요**

또한, 메모리를 더 쓰고, 포인터로 연결된 리스트를 관리해야 하므로 시간도 더 소요된다 
            
리스트 조작에는 연산 비용이 필요 (동적 메모리, 연결 관리 등)

캐시 친화도 ↓ → 메모리 접근 느릴 수 있음

<br/>

**적재율이 낮을 경우 개방주소법이 더 매력적일 수 있음**

체이닝은 해시 테이블 슬롯 수보다 원소가 많아도 저장 가능하지만 

앞에서부터 쌓이기 때문에 검색 시간이 점점 늘어남

적재율이 높아지면 리스트가 길어지고,

검색 성능이 저하되므로 → 결국 해시 테이블 확장 필요
















































