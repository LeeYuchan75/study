## 트리 시간복잡도 비교 

![image](https://github.com/user-attachments/assets/eaaf9974-d4fb-4954-9154-08d238a70f4c)

위 표에서 B트리의 설명 중 'Balanced binary search tree보다 상수 인자가 작다'라는 말은 

B-트리는 한 단계에 수십~수백 개 자식 가능하여 탐색 시간이 이진 트리보다 빠르다는 의미이다 

빠르다는 말은 이진 트리보다 상수 시간이 작아서 시간 복잡도는 같으나 실제 성능은 B트리가 좀 더 좋다는 뜻임 

<br/>

## 해시 테이블 

**해시 테이블 : 원소가 저장될 자리가 원소의 값에 의해 결정되는 자료구조**

트리에서도 값에 의해 위치가 달라지는 것 같지만 그건 트리를 그렸을 때의 위치이며 메모리 상에서의 위치는 키 값에 따라 달라지는 것이 아님

즉, **트리의 위치는 메모리의 위치와 무관함**

<br/>

트리의 내부 구조를 예시로 표현하면 

```ruby
Node(10) → 주소 0xA1
Node(5)  → 주소 0xDE
Node(20) → 주소 0x73
```

단지 Node(10).left = 0xB7 이런 식으로 포인터로 연결되는 것뿐 메모리와는 무관함 

트리는 원하고자 하는 값을 찾은 뒤에 해당 메모리에 접근하는 것 

<br/>

반면에 **해시 테이블은 해당 값에 직접적으로 대응하는 주소에 저장됨**

따라서 **내가 찾고자 하는 값 입력하면, 바로 메모리에 접근할 수 있음**

<br/>

## 해시테이블 장단점 

장점 :  **탐색 속도가 매우 빠름 -> 평균 O(1)**

단점 : **정렬 불가, 최대 최소 찾는데 오래걸림**

<br/>

해시 테이블과 비교하여 트리는 구조를 구성하는데 해시 테이블보다 시간이 좀 더 소요되지만

이렇게 만들어 놓으면, **정렬도 편리하고, 최대 최소를 찾는데 유리하다**

추가적으로 해시 테이블은 애초에 최소 원소를 찾는 것과 같은 작업은 지원하지 않는다 

<br/>

## 정리 

![image](https://github.com/user-attachments/assets/c512f903-30f9-43c0-8696-f6b06ababca4)

<br/>

## 적재율 

적재율 : **해시 테이블에 원소가 차 있는 비율** -> 해시 테이블의 성능에 큰 영향을 끼침

적재율 = 사용중인 공간 / 전체공간

<br/>

## 해시 함수 

해시 함수 : 임의의 키 값을 입력받은 후 일정한 구간 내의 값(해시 테이블 상의 주소)으로 변환하는 함수

아래와 같은 두 가지 성질을 만족하여야 함

<br/>

1. 입력 원소가 해시 테이블 전체에 골고루 저장될 수 있도록 해야 함

2. 계산이 간단해야 함

<br/>

첫 번째 조건이 굉장히 중요하며, 만약 서로 다른 키 값들에 대해서 같은 주소값을 반환하게 되면 충돌이 발생하여 해시 테이블의 성능이 저하됨

<br/>

## 해시 함수 예시 

예시를 위해 단순하게  해시 테이블의 크기로 mod 연산을 수행

**ℎ(𝑥)=𝑥mod𝑚**

이 때, 일반적으로𝑚은 2의 멱수(2𝑝)에 가깝지 않은 소수로 설정함. 그 이유를 아래 예시를 통해 살펴보자 

<br/>

```ruby
            100              ← 몫 (100₂ = 4 in decimal)
       ---------
10000 ) 1000101
         10000               ← 1 × 10000 = 10000 (16)
         ------
          000101
           00000             ← 0 × 10000 = 00000
           ------
            00101            ← 나머지 (하위 비트)
```

위 예시와 같이 2의 제곱수는 이진수에서 k000..00 꼴이다

따라서 나눗셈을 할 때 더이상 나눠지지 않은 부분은 k이하인데 

이 말은 k이하의 부분이 동일하면 **같은 해시 값을 갖는다는 의미이고 즉, 충돌 위험성이 커진다는 의미이다**

그래서 일반적으로 2의 제곱수에 가까운 소수를 택함 -> 소수는 이러한 현상 덜해서 충돌 위험성도 줄여줌(충돌이 존재하긴 함)

<br/>

## 곱하기 방법 

## h(x)=⌊m⋅(x⋅Amod1)⌋

![image](https://github.com/user-attachments/assets/e5040a5e-1521-45c8-8d5a-085a0cc17c7e)

위에서 한 내용이 나누기 방법이라면 이번에 할 것은 곱하기 방법이다 

나누기 방법은 큰 수를 해시 테이블 크기 범위 내로 들어오도록 축소시키지만, 

곱하기 방법은 입력값을 0과 1 사이의 소수로 대응시킨 다음 𝑚을 곱하여 0과 𝑚−1사이로 팽창시킴

<br/>

**위 함수의 각 원소 설명**

- x : 입력값

- A: 0 < A < 1인 임의의 값 

- mod 1 : 소수 부분을 구하기 위함 -> 나누기는 빼기의 반복

- m : 소수 부분에 곱해줄 임의의 값

<br/>

## 곱하기 방법 장점 

**1. 충돌이 줄어든다**

**2. 균등하게 만들어줌**

𝑚값은 어떻게 잡아도 성능에 큰 영향이 없고, **𝐴값에 따라 해시 값 분포가 달라짐**

<br/>

## 예시 

해시 함수 : h(x)=⌊m⋅(x⋅Amod1)⌋

입력값 : x=123

테이블 크기 : m=16

상수 A=0.6180339887 (→ 황금비의 역수 ≈ 무작위성 좋음)

<br/>

**1. x 곱하기 A**

123⋅0.6180339887 = 76.0171806

<br/>

**2. 소수 부분만 추출**

76.0171806mod1 = 0.0171806

<br/>            

**3. m 곱하기 소수 부분**

16⋅0.0171806 = 0.2748896

<br/>

**4. 정수 부분만 취하기**

⌊0.2748896⌋ = 0

<br/>

## 충돌 

충돌 : 1해시 테이블의 한 주소를 놓고 두 개 이상의 원소가 자리를 다투는 것

충돌 해결 방법은 크게 두 가지가 있다

1. 체이닝(Chaining)

2. 개방주소 방법(Open Addressing)

<br/>

## 체이닝 

체이닝 기법 : 같은 해시값을 가지는 여러 데이터를 **연결 리스트로 이어서 저장하는 충돌 해결 방법**

체이닝 기법은 다음과 같은 특징을 갖는다 

**1. 해시 테이블 외에 추가적인 메모리가 필요함**

**2. 적재율이 1이 넘어가도 작동에는 문제 없음**

<br/>

여기서 **적재율이 1이 넘어가도 작동에 문제가 없다는 것은 효율적이라는 의미가 아니다**

이 경우 상수시간을 보장하지 않은 경우가 많음

<br/>

## 체이닝 알고리즘 

```ruby
chainedHashInsert(T[ ], x)
▷ T : 해시 테이블, x : 삽입 원소
{
    리스트 T[h(x)]의 맨 앞에 x를 삽입;
}

chainedHashSearch(T[ ], x)
▷ T : 해시 테이블, x : 검색 원소
{
    리스트 T[h(x)]에서 x값을 가지는 원소를 검색;
}

chainedHashDelete(T[ ], x)
▷ T : 해시 테이블, x : 삭제 원소
{
    리스트 T[h(x)]에서 x의 노드를 삭제;
}
```





















































































