## 행렬 곱셈 문제 

행렬 연산에 대해 복습을 해보자면, 행렬곱은 교환법칙이 성립하지 않지만 결합법칙은 성립한다

예를 들어행렬 𝐴,𝐵,𝐶에 대해 𝐴(𝐵𝐶) = (𝐴𝐵)𝐶 가 성립한다 

따라서 여러 개의 행렬이 곱해진 경우에 해당 곱을 구하기 위해 다양한 순서가 존재하며, 그 **순서에 따라** 연산 횟수가 크게 달라지기도 한다

만약 𝐴는 10×100 , 𝐵는 100 × 5, 𝐶는 5 × 50의 shape을 갖고 있다면

- (𝐴𝐵)𝐶: 7500번 스칼라 곱셈 필요

- 𝐴(𝐵𝐶): 75000번 스칼라 곱셈 필요

<br/>

이에 행렬곱 𝐴1𝐴2𝐴3…𝐴𝑛 을 가장 **효율적으로** 연산하는 **공식을 찾는 것이** 행렬 곱셈 문제의 **목표**이다

<br/>

행렬곱 𝐴1𝐴2𝐴3…𝐴𝑛 을 수행하기 위해 𝑛−1번의 행렬곱을 수행하여야 하는데, 이 때 마지막 순서로 행렬곱을 하는 상황을 나타내보면 아래와 같이 𝑛−1개의 경우의 수가 있다

- A1(A2 … An )

- (A1A2)(A3 … An)

- (A1A2 A3)(A4 … An)

- ∙ ∙ ∙

- (A1 … An-2) (An-1An)

- (A1 … An-1)An

위 경우들 중 어느 경우가 가장 효율적인지를 **최적 부분구조**를 활용하여 구할 수 있다

<br/>

현재 상황에서의 행렬곱 형태를 **일반화하면** (𝐴1…𝐴𝑘)(𝐴𝑘+1…𝐴𝑛) 으로 표현 가능하다

그리고 이 때 특정 𝑘에 대한 곱셈 비용은 **앞쪽 괄호로 엮인** 행렬곱의 비용, **뒤쪽 괄호로 엮인** 행렬곱의 비용 및 괄호 안의 연산이 모두 끝난 **두 행렬을 곱하는 비용**을 더하면 계산할 수 있다

![image](https://github.com/user-attachments/assets/d28c2906-f615-4bb5-aef6-13aaa51f31b3)

<br/>

주어진 공식에서 pi-1 * pk * pj가 의미하는 바는 **행렬의 곱센 연산 횟수**이다

만약 3x2 행렬과 2x1 행렬을 곱한다면, 최종 행렬은 3x1 행렬이 되는데, 이때 **두 행렬을 연결시키는 숫자만큼** 각 요소를 반복해서 결과가 나온 것이다 

즉, 3x1개의 요소를 각각 2번의 곱셈을 이용하여 출력한 것이므로, 총 3 x 2 x 1 번의 결과가 수행이 된 것이다 

이를 일반화 하여 **pi-1 * pk * pj** 라고 표현한다

<br/>

이것을 이용하여 재귀함수를 살펴 보자 

<br/>

## 행렬 곱셈 문제 & 재귀 함수 

```ruby
rMatrixChain(i, j)
▷ 행렬곱 A_i ... A_j 를 구하는 최소 비용 구하기
{
    if (i == j) then return 0;          ▷ 행렬이 하나뿐인 경우, 곱셈 필요 없음 → 비용 0

    min ← ∞;                            ▷ 최소 값을 의미하는 임의의 작은 수를 의미

    for k ← i to j - 1 {
        q ← rMatrixChain(i, k) + rMatrixChain(k + 1, j) + p_{i-1} * p_k * p_j;   ▷ 두 부분의 최소 비용 + 최종 곱셈 비용

        if (q < min) then min ← q;
    }

    return min;
}
```

주어진 행렬 곱셈 문제를 재귀 함수로 풀어나간 과정을 살펴 보면 

i == j 일 때는 자기 자신을 연산하는 것이므로 비용이 들지 않는다.

이후 for문을 살펴 보면, 각각 i와 j는 고정이 되어 있고, **사이에 k가 움직이며** 모든 경우를 계산하는 방식이다 

<br/>

위에서 일반화시킨 pi-1 * pk * pj를 이용하여 k로 분리하였을 때 값을 계산하고, 이후 재귀적으로 실행되어 

**i ~ k** 와 **k + 1 ~ j** 를 또 다시 for문을 통해서 분리하여 계산하는 과정을 반복한다 

추가적으로 재귀 함수를 호출할 때 해당 함수의 j역할을 하는 k와 for문의 k의 변수가 같아지는데, 둘의 관계는 독립적이라 문제가 되지 않는다

<br/>

## 행렬 곱셈 문제 & 재귀 함수 시간 복잡도 

- P(n): 행렬 A1 ~ An 을 곱할 때 드는 재귀 호출 수

- P(k): 왼쪽 부분 (i ~ k)

- P(n-k): 오른쪽 부분 (k+1 ~ j)

![IMG_3186](https://github.com/user-attachments/assets/1054ca91-b85d-4062-b013-2e67cbed0486)

주어진 공식과 같이 c가 1/4 이상의 모든 n에 대해 성립하고, 따라서 rMatrixChain은 n에 대해 지수 함수적으로 증가한다.

즉, 수행 시간은 **Ω(2^n) (빅 오메가)** 이다. 매우 비효율적인 알고리즘이라는 것을 확인할 수 있다 

<br/>

## 행렬 곱셈 문제 & DP 

일반적인 재귀 알고리즘으로 구현하면 Ω(2𝑛)의엄청난 연산 시간이 소요되지만, 부분 문제의 모든 경우의 수를 살펴보면

가능한 𝑖,𝑗조합의 경우의 수는 전체 행렬을 분리하는 경우가 n-1이고 이렇게 분리된 행렬을 또 다시 분리하는데 n-2가 걸리며 이것이 반복된다.

즉, 𝑛 + 𝑛−1 + 𝑛 −2 + ⋯ + 1 이므로 **n(n+1) / 2** 개밖에 되지 않는다 (원래는 n-1 부터 시작)

![IMG_3187](https://github.com/user-attachments/assets/1df18125-b6e3-4823-b80c-1e7b6641b9c1)

이에 가능한 부분 문제의 수에 비해 연산 횟수가 기하급수적으로 증가하므로 **동적 프로그래밍**을 통해 중복 연산을 방지하면 **효율성이 크게 개선**된다

<br/>

## 행렬 곱셈 문제 & DP 구현 

```ruby
matrixChain(n)
{
    for i ← 1 to n
        m[i, i] ← 0;  ▷ 행렬이 하나뿐인 경우의 비용은 0 (ex m[1,1] , m[2,2], ...)

    for r ← 1 to n - 1   ▷ r: 문제 크기를 결정하는 변수 (문제 크기 = r + 1)
        for i ← 1 to n - r {
            j ← i + r;
            m[i, j] ← min {m[i, k] + m[k+1, j] + p_{i-1} * p_k * p_j}
               
            };

    return m[1, n];
}
```

## p.21 부터 공부 














































































