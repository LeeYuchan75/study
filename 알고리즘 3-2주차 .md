## 병합 정렬 

정의 : 배열을 반으로 나누고, 각 부분을 재귀적으로 정렬한 후, 두 개의 정렬된 부분 배열을 병합하여 최종적으로 정렬된 배열을 생성하는 알고리즘

```ruby
mergeSort(A[ ], p, r)      
▷A[p... r]을 정렬한다. 

{ 
    if (p< r) then{ 
        q← (𝑝+𝑞)/2;   -----------------①▷p, q의 중간 지점 계산 
        mergeSort(A, p, q);----------------②▷전반부 정렬 
        mergeSort(A, q+1, r); --------------③▷후반부 정렬 
        merge(A, p, q, r);------------------④▷병합 
    } 
}

merge(A[ ], p, q, r) 
{ 
    정렬되어 있는 두 배열 A[p... q]와 A[q+1 ... r]을 합쳐
    정렬된 하나의 배열 A[p... r]을 만든다. 
} 

```

<br/>

## 병힙 정렬 예시

![IMG_3061](https://github.com/user-attachments/assets/e930e11b-e778-460f-823c-f8c173b38065)

<br/>

## 병합 정렬 시간복잡도

병합 정렬의 시간복잡도는 O(nlogn)이 걸린다 

<풀이>

배열을 나눌 때마다 크기가 절반이 되므로, 배열의 크기는 n, n/2, n/4, n/8, …, 1과 같이 줄어든다

배열 크기가 n에서 시작해서 n/2^k = 1이 될 때까지 나누고, 이를 방정식으로 나타내면 n/2^k = 1이다

이 방정식에서 양변에 log2를 취하면 k = logn이 되므로 배열을 크기 1까지 나누는 데 걸리는 단계 수는 logn이다

따라서 병합정렬에서 분할을 하는데 O(logn) 만큼 걸리고 

병합 단계에서 두 배열의 원소를 한 번씩 확인하며 처리하므로, 병합 과정의 시간 복잡도는 **O(n)** 이다

즉 O(n) 을 O(logn) 만큼 반복하므로 총 시간 복잡도는 O(nlogn) 이다 

<br/>

**Best case, Average case, Wrost case 모두 Θ(nlogn)임**

<br/>

## 퀵정렬 

정의 : 하나의 요소를 **피벗(pivot)** 으로 선택하여, pivot보다 작은 값들과 큰 값들을 두 개의 부분 배열로 나누고, 각 부분 배열을 재귀적으로 정렬하는 알고리즘

```ruby
quickSort(A[], p, r)   ▷ A[p ... r]을 정렬한다 
{ 
    if (p < r) then { 
        q = partition(A, p, r); ▷ 분할 
        quickSort(A, p, q-1); ▷ 왼쪽 부분 배열 정렬 
        quickSort(A, q+1, r); ▷ 오른쪽 부분 배열 정렬 
    } 
}

partition(A[], p, r) 
{ 
    배열 A[p... r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 (즉, pivot을 마지막 원소로 사용, pivot 기준은 다양함)
    A[r]이 자리한 위치를 리턴한다; 
}
```

<br/>

## 세부적인 알고리즘 

![스크린샷 2025-03-23 215352](https://github.com/user-attachments/assets/3b227e1f-1018-4986-8df1-60c98590e6a8)

<br/>

## 예시 

![스크린샷 2025-03-23 215404](https://github.com/user-attachments/assets/cd2d36a3-e40c-41ea-a7e6-41b24eefdc2c)

![스크린샷 2025-03-23 215411](https://github.com/user-attachments/assets/546072d6-e2b3-4c4a-a269-df4177c393e5)

<br/>

## 퀵 정렬 시간 복잡도 

**1. Worst case : Θ(n²)**

최악의 경우는 **분할 수행 후 원소들이 pivot 앞이나 뒤쪽에만 모두 몰려있을 때**이다

이 경우, 배열은 매번 하나의 원소만 남고, 나머지 원소들은 계속 한쪽 부분으로만 치우쳐서 분할됨

이처럼 비대칭적인 분할이 계속되면, 각 단계에서 비교가 n번씩 일어나고, 

총 비교 횟수는 n + (n-1) + (n-2) + ... + 1이 되어 O(n²) 시간이 걸리게 되어 최악의 경우 퀵정렬의 시간 복잡도는 Θ(n²)로 계산된다 

<br/>

## 정리 

![image](https://github.com/user-attachments/assets/f31401cf-8874-44ef-b222-c8551456b926)

<br/>

## 퀵 정렬 average case

피벗이 항상 배열을 정확히 절반으로 나누지는 않지만, 분할이 비교적 균형 있게 이루어지는 경우이다

**이 경우 평균적으로, 재귀 깊이는 여전히 O(log n) 수준을 유지함** 이는 분할이 심하게 불균형하지 않는 한, 재귀 깊이가 로그 수준을 넘지 않음을 의미

<br/>

## Divide and Conquer

아래의 의사코드에서처럼 문제를 더 작은 사이즈의 문제로 나타내고 이를 재귀 호출로 해결한 다음 다시 합치는 형식의 알고리즘을 의미함

**병합정렬 및 퀵정렬은 대표적인  divide and conquer 알고리즘**

![image](https://github.com/user-attachments/assets/98ee546e-7688-4cb7-9136-f9414a9747a6)

<br/>

## 퀵 정렬의 장점

병합정렬은 worst case에서 퀵정렬보다 앞서고 average 및 best case에서는 퀵정렬과 동일한 시간 복잡도를 가진다

**그러나 퀵정렬이 일반적으로 더 빠른 수행 속도를 보이게 되는 이유는 컴퓨터 구조와 연관이 있다**

실제 컴퓨터 구조 상으로 변수의 접근은 메모리 뿐 아니라 캐쉬(cache)에 의해서도 이루어지는데, 

메모리보다는 cpu에 더 가까운 캐쉬에 있는 내용들이 훨씬 접근이 빠르기 때문이다 

<br/>

병합정렬은 아래 예시와 같이 인덱스 상으로 끝에서 끝을 계속 왔다갔다 하며 정렬을 수행함

즉, 낮은 인덱스의 데이터들이 캐쉬에 저장되었다가 지워졌다가 다시 큰 인덱스의 데이터들이 

캐쉬에 저장되는 등의 과정을 반복하며 데이터 접근 속도 면에서 비효율성을 보임

<br/>

반면 퀵정렬은 처음에 기준원소에 대해 정렬한 이후에는 비교적 국소적인 부분을 대상으로 정렬을  수행하므로 cache hit ratio(찾고자 하는 정보가 캐쉬에 있을 확률)이 높아져 데이터 접근이 빠름

따라서 알고리즘 상으로 분석할 때는 병합정렬이 더 우수해 보이지만 실제로 사용하는 컴퓨터 구조 상에서의 연산 속도 측면에서 퀵정렬이 일반적으로는 더 우위에 있음

또한 퀵정렬은 주어진 배열 공간만으로 정렬이 가능하고 병합정렬은 추가적인 메모리가 필요함

데이터 크기가 매우 커지는 경우에는 병합정렬이 상대적으로 성능이 더 우수한 경향을 보인다

<br/>

## stable sort 

stable sort : 정렬 전 동일한 값(키)을 가진 원소들의 상대적인 순서가 정렬 후에도 유지되는 정렬 알고리즘을 의미

ex) (3,A),(1,B),(3,C),(2,D),(1,E) -> (1,B),(1,E),(2,D),(3,A),(3,C) => A~E까지 순서를 유지하며(인덱스를 유지하며) 정렬

merge sort == stable sort 

quick sort != stable sort

<br/>


## 정렬 정리 

**1. 삽입 정렬 (Insertion Sort)**

**리스트를 앞에서부터 하나씩 정렬된 상태로 만들어가는 알고리즘**

Best case: Θ(n)

Average case: Θ(n²)

Worst case: Θ(n²)

<br/>

**2. 선택 정렬 (Selection Sort)**

**최대 또는 최솟값을 마지막 원소와 바꿈**

Best, Average, Worst case: Θ(n²)

<br/>

**3. 버블 정렬 (Bubble Sort)**

**인접한 두 원소를 비교하면서 자리를 교환해 정렬하는 방법**

Best, Average, Worst case: Θ(n²)

<br/>

**4. 퀵 정렬 (Quick Sort)**

**피벗 기준으로 분리하여 정렬**

Best case : Θ(nlogn)

Average case: Θ(nlogn)

Worst case: Θ(n²)

<br/>

**5. 병합 정렬 (Merge Sort)**

**배열의 중간을 재귀적으로 반으로 나누어 정렬 후 병합**

Best, Average, Worst case: Θ(nlogn)
































