## 병합 정렬 

정의 : 배열을 반으로 나누고, 각 부분을 재귀적으로 정렬한 후, 두 개의 정렬된 부분 배열을 병합하여 최종적으로 정렬된 배열을 생성하는 알고리즘

```ruby
mergeSort(A[ ], p, r)      
▷A[p... r]을 정렬한다. 

{ 
    if (p< r) then{ 
        q← (𝑝+𝑞)/2;   -----------------①▷p, q의 중간 지점 계산 
        mergeSort(A, p, q);----------------②▷전반부 정렬 
        mergeSort(A, q+1, r); --------------③▷후반부 정렬 
        merge(A, p, q, r);------------------④▷병합 
    } 
}

merge(A[ ], p, q, r) 
{ 
    정렬되어 있는 두 배열 A[p... q]와 A[q+1 ... r]을 합쳐
    정렬된 하나의 배열 A[p... r]을 만든다. 
} 

```

<br/>

## 병힙 정렬 예시

![IMG_3061](https://github.com/user-attachments/assets/e930e11b-e778-460f-823c-f8c173b38065)

<br/>

## 병합 정렬 시간복잡도

병합 정렬의 시간복잡도는 O(nlogn)이 걸린다 

<풀이>

배열을 나눌 때마다 크기가 절반이 되므로, 배열의 크기는 n, n/2, n/4, n/8, …, 1과 같이 줄어든다

배열 크기가 n에서 시작해서 n/2^k = 1이 될 때까지 나누고, 이를 방정식으로 나타내면 n/2^k = 1이다

이 방정식에서 양변에 log2를 취하면 k = logn이 되므로 배열을 크기 1까지 나누는 데 걸리는 단계 수는 logn이다

따라서 병합정렬에서 분할을 하는데 O(logn) 만큼 걸리고 

병합 단계에서 두 배열의 원소를 한 번씩 확인하며 처리하므로, 병합 과정의 시간 복잡도는 **O(n)** 이다

즉 O(n) 을 O(logn) 만큼 반복하므로 총 시간 복잡도는 O(nlogn) 이다 

<br/>

**Best case, Average case, Wrost case 모두 Θ(nlogn)임**

<br/>

## 퀵정렬 

정의 : 하나의 요소를 **피벗(pivot)** 으로 선택하여, pivot보다 작은 값들과 큰 값들을 두 개의 부분 배열로 나누고, 각 부분 배열을 재귀적으로 정렬하는 알고리즘

```ruby
quickSort(A[], p, r)   ▷ A[p ... r]을 정렬한다 
{ 
    if (p < r) then { 
        q = partition(A, p, r); ▷ 분할 
        quickSort(A, p, q-1); ▷ 왼쪽 부분 배열 정렬 
        quickSort(A, q+1, r); ▷ 오른쪽 부분 배열 정렬 
    } 
}

partition(A[], p, r) 
{ 
    배열 A[p... r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 
    A[r]이 자리한 위치를 리턴한다; 
}
```



































