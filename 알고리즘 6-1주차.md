## B 트리 

B-트리: 데이터베이스에 활용되는 트리 구조로써 메모리 상에 모두 올려놓고 사용하는 것이 아닌 **디스크에 저장된 상태로 필요한 부분만 메모리에 로드**하여 활용하기 좋은 자료구조

<br/>

컴퓨터는 데이터를 메모리(RAM)에 접근할 때 매우 빠르지만, 하드디스크(HDD)나 SSD와 같은 디스크에서 데이터를 가져올 때는 상대적으로 시간이 많이 걸림

그래서 디스크에서 데이터를 읽는 횟수를 최소화하는 것이 속도를 높이는 핵심인데 

**B-트리는 한 번에 여러 개의 데이터를 묶어서 하나의 노드에 저장할 수 있다**

<br>

이렇게 하면 같은 양의 데이터를 저장할 때 **일반적인 이진 트리보다 트리의 높이가 낮아지기 때문에**

디스크에서 데이터를 찾을 때, 데이터가 있는 위치를 찾기까지의 **디스크 접근 횟수가 줄어든다**

삽입 및 삭제 과정에서의 연산 횟수가 이진 트리에서보다 줄어드는 효과가 있음 (점근적으로는 같음)

<br/>

이를 기반으로 B-트리의 정의를 말하면 **B-트리는 디스크 기반 환경에서 효율적인 데이터 접근 및 연산 성능을 보장하는 자료구조이다**

<br/>

## B-트리 구조 

![스크린샷 2025-04-11 180955](https://github.com/user-attachments/assets/b1742b77-907c-4d32-afaf-02e7a6ad52f5)

![image](https://github.com/user-attachments/assets/8417546c-d4d3-4e38-a2d4-76457f397647)

노드 내에서 각 레코드에 대한 정보는 **<키 값, 페이지 주소>** 로 이루어져 있으며, 이에 특정 페이지에 접근한 후 그 다음에 정확한 해당 키 값의 레코드를 찾기 위해서는 탐색 과정이 필요함

**페이지는 크기가 크지 않으므로 이 과정은 연산 부담이 크지 않음**

<br/>

## Mysql & B-트리 예시

```ruby
CREATE TABLE 학생 (
    학번 INT PRIMARY KEY,
    이름 VARCHAR(50)
);
```

만약 저정된 학번이 1001, 1002, 1003 이라면 key 값으로 1001, 1002, 1003을 갖고 각각 알맞는 페이지 할당한다 (깊게 공부x 범위에 너무 벗어남)

이후, 데이터를 삽입하거나 삭제할 때, **처리하고 싶은 학번을 트리 구조에서 찾고, 그 값에 해당하는 페이지에 들어가 실제 값을 변경하는 구조임**

페이지를 하나씩 다 찾는 것보단 **트리 구조로 값들을 규칙적으로 분배하면 찾는 속도가 빨라지기 때문**

만약 찾고자 하는 키 값이 있다면, 더 아래의 서브트리로 내려가지 않고 페이지 번호를 참조하여 해당 레코드를 읽고

찾고자 하는 키 값이 없는 경우는 알맞은 서브트리로 내려가서 다시 재귀적으로 검색 수행

<br/>

## B-트리 성질

1. 루트를 제외한 모든 노드는 키 k/2 ~ k개의 키를 갖는다 -> ex: 최대 키 개수 k=4라면, 모든 일반 노드는 최소 2개, 최대 4개의 키를 갖게 됨

2. 모든 리프 노드는 같은 깊이를 가진다 -> B-트리는 항상 균형 잡힌 형태를 유지하고, 이는 데이터 접근 시간을 일정하게 유지하는 데 중요한 역할을 한다

3. B-트리는 각 노드 내부의 키 값이 항상 정렬된 상태를 유지함

<br/>

![image](https://github.com/user-attachments/assets/bc210641-8648-4031-bdeb-3b98f8b02780)

<br/>

## B-트리 삽입 알고리즘 

```ruby
BTreeInsert(t, x)
{
    ▷ x를 삽입할 리프 노드 r을 찾는다;
    ▷ x를 r에 삽입한다;

    if (r에 오버플로우 발생) then clearOverflow(r);
}

clearOverflow(r)
{
    if (r의 형제 노드 중 여유가 있는 노드가 있음) then {
        ▷ r의 남는 키를 넘긴다;
    } else {
        ▷ r을 둘로 분할하고 가운데 키를 부모 노드로 넘긴다;  ▷ 형제 노드까지 꽉 찬 경우
        if (부모 노드 p에 오버플로우 발생) then clearOverflow(p);  ▷ 부모 노드까지 꽉 찬 경우 -> 재귀적으로 처리 
    }
}
```

<br/>

## B-트리 예시 

![BTree_Insert_Merged_2](https://github.com/user-attachments/assets/03f8ac7d-b1e8-4b14-ac65-cc7f5af55d17)

<br/>

## B-트리 삭제 알고리즘 

```ruby
BTreeDelete(t, x, v)
{
    if (v가 리프 노드 아님) then {
        x의 직후원소 y를 가진 리프 노드를 찾는다;
        x와 y를 맞바꾼다;
    }
    리프 노드에서 x를 제거하고 이 리프 노드를 r이라 한다;
    if (r에서 언더플로우 발생) then clearUnderflow(r);
}

clearUnderflow(r)
{
    if (r의 형제 노드 중 키를 하나 내놓을 수 있는 여분을 가진 노드가 있음)
        then { r이 키를 넘겨받는다; }
    else {
        r의 형제 노드와 r을 합병한다;     ▷ 이때 r과 r의 형제 노드 사이에 있는 부모 노드의 값도 같이 합병함
        if (부모 노드 p에 언더플로우 발생) then clearUnderflow(p);
    }
}
```






































































