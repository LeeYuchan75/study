## Storage Hierarchy

저장 장치는 **volatile storage (휘발성 저장장치)** 와 **non-volatile storage (비휘발성 저장장치)** 로구분할 수 있다

- **휘발성 저장장치** : 전원이 꺼지면 내용이 사라진다 (ex: RAM)

- **비휘발성 저장장치** : 전원이 꺼져도 데이터를 유지하는 저장장치, 2차, 3차 저장장치뿐 아니라 배터리 백업된 주기억장치도 포함 (ex: SSD, HDD)

<br/>

### 저장 매체 선택에 영향을 주는 요인

- 데이터를 얼마나 빨리 접근할 수 있는가

- 데이터 단위당 비용

- 신뢰성

<br/>

![IMG_3367](https://github.com/user-attachments/assets/b229f2d2-aa04-4bc6-ad5d-888aae94f4d0)

<br/>

## Magnetic Hard Disk Mechanism (자기 하드디스크 구조)

![IMG_3368](https://github.com/user-attachments/assets/94575315-a727-4ea9-bed5-cedf69ba6ce2)


### 자기 하드디스크 구조에서 디스크 저장 방식

플래터 표면은 자성을 띤 물질로 코팅되어 있다

여기에 **자기장을 이용해 0과 1을 기록**함. 자기 방향이 ↗면 0, ↘면 1 처럼 약속되어 있다 

<br/>

파일, 사진, 동영상, 프로그램, 운영체제 등 컴퓨터의 모든 정보가 결국은 0과 1 (비트)로 바뀌어서 sector 단위로 디스크에 저장된다

<br/>

그래서 물리 디스크에 0과 1이 자성으로 새겨져서 전원을 꺼도 내용이 안 사라지는 원리이다 

<br/>

**모든 디스크가 다 자기장으로 이루어진 것은 아님**

대표적으로 **자기장을 이용하는 건 HDD**아고, SSD나 CD/DVD는 **전기 또는 빛을 이용**

<br/>

## Disk Controller

**Disk controller** : 컴퓨터 시스템과 디스크 드라이브 하드웨어 사이를 연결하는 장치

- 디스크 팔을 움직이고 데이터를 읽고 쓰는 명령을 수행한다 즉, CPU가 해당 위치 읽으라고 하면 실질적인 동작은 컨트롤러가 수행

- 데이터가 손상되었는지 확인하기 위해 **checksums**을 계산하여 붙임

- **손상된 섹터가 있으면 다른 위치**로 논리적으로 연결해줌

<br/>

## 디스크 평가 방식

### Access time

- read-write 요청 후 실제 전송이 시작되기까지 걸리는 시간

<br/>

### Seek time

- 헤드를 원하는 트랙으로 옮기는 데 걸리는 시간

- 평균 탐색 시간 = 최악의 경우의 절반

- 일반적으로 4~10ms

<br/>

### Rotational latency

- sector가 회전하여 헤드 아래 올 때까지 기다리는 시간

- 회전속도에 따라 달라짐 (5400~15000rpm), 평균은 절반 시간

- 일반적으로 4~11ms

<br/>

**전체 평균 지연 시간 = 5m~ 20ms**

<br/>

### Data-transfer rate

- 데이터를 얼마나 빠르게 읽고 쓸 수 있는가

- 초당 25~200MB 가능 (트랙 위치에 따라 다름, 바깥쪽이 빠름)

<br/>

### Mean time to failure (MTTF)

- 디스크가 고장 없이 계속 작동할 것으로 예상되는 평균 시간

- ex: 1,200,000시간 MTTF → 1000개의 디스크 중 평균적으로 1200시간마다 1개 고장난다는 의미 

<br/>

## Flash Storage (플래시 저장장치)

Flash Storage에서 NAND flash와 SSD에 대해 알아보자 

### NAND flash

- 저장용으로 널리 사용되며, NOR 플래시보다 저렴하다

- 데이터를 한 번에 '페이지 단위(512B ~ 4KB)'로 읽어야 함

- 한 페이지를 읽는 데 약 20~100마이크로초가 걸린다

- 한 페이지는 한 번만 쓸 수 있다

<br/>

### Solid state disks (SSD)

- 표준 블록 단위 디스크 인터페이스(SATA 등)를 사용하지만, 내부적으로는 여러 개의 플래시 메모리 장치에 데이터를 저장함

-  SATA 인터페이스로는 최대 500MB/s, NVMe PCIe 인터페이스로는 최대 3GB/s의 전송 속도를 제공

<br/>

## RAID (Redundant Arrays of Independent Disks)

- **RAID** : 많은 디스크를 관리하면서 하나의 디스크처럼 보이게 하는 저장 구성 기법

- 여러 디스크를 병렬로 사용해 **high capacity (높은 용량)** 과 **high speed (높은 속도) 제공**

<br/>

### RAID -> Redundancy (중복 저장) - 안정성 향상

- RAID는 중복 저장을 하여 안정성을 향상시킨다

- 즉, 디스크 손실 시 복구에 사용할 수 있는 추가 정보를 저장하는 것

- ex : Mirroring (or shadowing) : 모든 디스크를 복제함

<br/>

논리 디스크는 물리적으로 두 개의 디스크로 구성됨

- write는 항상 두 디스크에 동시에 기록

- read는 둘 중 아무 디스크에서나 가능

- 한 디스크가 고장 나도 나머지에 데이터가 있다

<br/>

따라서 기존 디스크와 미러 디스크가 **둘 다 고장 나기 전까지는 데이터 손실이 없음**

<br/>

### Performance via Parallelism (성능 향상)

**디스크 시스템에서 병렬 처리의 두 가지 주요 목표**

1. 작은 작업들을 분산시켜 **전체 처리량(throughput) 증가** -> 동시에 처리하기 때문에 **분산시키는게 효율적**

2. 큰 작업들을 병렬화시켜 **응답 시간(response time) 감소**

여러 디스크에 데이터를 **striping(나눠서)** 저장해 전송 속도 향상한다

병렬 처리에서의 저장 방식은 **Bit-level striping**과 **Block-level striping**이 존재한다 

<br/>

### Bit-level striping

- 각 바이트의 비트를 여러 디스크에 나눠 저장

- ex: 8개의 디스크가 있으면 바이트의 각 비트를 하나씩 나눠 저장

- 위 예시를 에서는 속도가 8배지만, **탐색 시간이 길다는 단점 존재**

- **요즘에는 잘 안씀**

<br/>

### Block-level striping

- 블록 단위로 디스크에 나눠 저장 (i번째 블록 → (i mod n) + 1번 디스크, +1를 하는 이유는 0번 디스크가 없기 때문)

- **서로 다른 블록 요청은 동시에 처리 가능**

- **연속된 블록 요청도 병렬로 빠르게 처리 가능**

<br/>

## RAID Levels 

### RAID 전체 목적

데이터를 여러 디스크에 분산하여

- 속도는 빠르게

- 고장나도 복구 가능하게

- 비용은 적절히 조절

<br/>

그래서 등장한 게 **RAID Levels**이다 → 각 레벨마다 성능, 안정성, 비용이 다름

RAID Levels은 디스크 스트라이핑 + 패리티 비트를 이용해 저렴하게 중복성을 제공하는 방식이다 

RAID 레벨에 따라 비용, 성능, 신뢰성이 다르게 나타난다 

<br/>

### RAID Level 0 : Block striping; non-redundant

- **성능이 중요**하고 **데이터 손실이 괜찮은 상황**에서 사용됨

- 데이터를 여러 디스크에 분산 저장해 속도는 빠르지만 **복구 불가** → **한 디스크만 고장 나도 전체 데이터 손실**

<br/>

### RAID Level 1 : Mirrored disks with block striping

- **write 성능이 매우 우수**

- DB의 로그파일 저장처럼 속도와 복구 모두 중요한 곳에서 사용

- 데이터를 복제하여 저장하므로 **신뢰성 최고, 속도도 우수**하지만 **디스크 공간은 2배 필요하는게 단점**

![image](https://github.com/user-attachments/assets/6226e9ba-d20d-495d-8d13-15e0e11877e2)

<br/>

### RAID Level 5 : Block-Interleaved Distributed Parity

- 데이터를 N개의 디스크에 저장하고, 패리티를 1개 디스크에 몰아두는 대신, N+1 전체 디스크에 골고루 분산하여 저장함

- 여기서 **패리티란 검사하는 비트**이다. 즉 고장이 난 디스크를 복구하기 위한 비트이며 아래 예시에서 설명한다 

![IMG_3370](https://github.com/user-attachments/assets/7fca927d-246c-4e5c-a203-e47d2bec44cb)

아래는 디스크가 고장이 났을 때 XOR를 이용하여 복구하는 예시이다 

<br/>

### XOR 복구 예시 

- D1 = 10110010

- D2 = 11001100

- D3 = 01100110

### 패리티 계산 : P = D1 ⊕ D2 ⊕ D3

```ruby
D1 = 10110010  
D2 = 11001100  
---------------- XOR
    = 01111110  

(중간 결과)  
01111110 ⊕ D3 = 01111110 ⊕ 01100110  
               = 00011000

→ P = 00011000
```

<br/>

### 복구 예시 (D2가 손실된 경우)

알고 있는 값 

- D1 = 10110010

- D3 = 01100110

- P = 00011000

```ruby
D1 ⊕ D3 = 10110010 ⊕ 01100110 = 11010100  
11010100 ⊕ P = 11010100 ⊕ 00011000 = 11001100  

→ 복구된 D2 = 11001100 
```

<br/>

## RAID Level 6

- **P와 Q라는 두 가지 오류 정정 블록을 사용**하는 중복 방식, **2개의 디스크 고장까지 복구 가능**

-  RAID 5와 유사하지만, 하나의 패리티 블록 대신 **두 개의 오류 정정 블록(P, Q)** 을 저장하여 다중 디스크 오류에 대비함

-  RAID 5보다 신뢰성은 높지만, 비용은 더 비쌈

-  저장장치 크기가 커질수록 중요성이 커짐

![image](https://github.com/user-attachments/assets/0c42095a-e1d3-482e-a42e-67015812c47d)

<br/>

##  RAID 수준 선택 시 고려 요소

RAID 수준 선택 시 4가지 고려 요소에 대해 살펴보자 

1. Monetary cost : 비용 (디스크 수, 하드웨어 요구사항 등)

2. Performance : 일반적인 동작 중 초당 입출력(I/O) 수, 대역폭 등 성능

3. Performance during failure : 디스크 오류가 발생했을 때의 성능

4. Performance during rebuild of failed disk : 고장 디스크 복구 중의 성능 (디스크 복구 시간 포함)

<br/>

## RAID 수준별 특성과 사용처

### Level 1

- RAID 1은 RAID 5보다 **훨씬 더 나은 쓰기 성능 제공**

- RAID 5는 한 블록을 쓰기 위해 최소 2번 읽고 2번 써야 하지만, **RAID 1은 단지 2번만 쓰면 됨**

- RAID 1은 무작위/소규모 쓰기가 많은 애플리케이션에 적합

- **RAID 1은 저장 비용이 RAID 5보다 높음**

<br/>

### Level 5

- RAID 5는 **순차적이고 큰 데이터를 쓰는 경우**에 적합

- **많은 저장 공간이 필요한 경우** 선호됨

<br/>

### Level 6

- RAID 6은 RAID 5보다 **더 나은 데이터 보호 기능** 제공 -> **디스크 2개 고장까지 복구 가능하기 때문**

- 한 디스크에서 발생한 잠재적 오류와 다른 디스크 고장이 결합할 경우, RAID 1이나 5는 위험 → **RAID 6의 중요성 증가**

<br/>

### 정리 

- RAID 1: 빠른 쓰기, 높은 비용, 무작위 업데이트에 유리

- RAID 5: 순차적 데이터 쓰기 + 대용량 스토리지에 적합

- RAID 6: 높은 신뢰성, 2개 디스크 고장에도 안전 (점점 더 중요해짐)















