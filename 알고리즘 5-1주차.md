## record and field

**record(레코드) : 개체에 대해 수집된 모든 정보를 포함하고 있는 저장 단위**

사람의 레코드 예시: 주민번호, 이름, 집주소, 집 전화번호, 직장 전화번호, 휴대폰 번호, 최종 학력, 연소득, 가족 (상황 등의 정보 포함)

<br/>

**field(필드) : 레코드에서 각각의 정보를 나타내는 부분**

예시 : 위 사람의 레코드에서 각각의 정보를 나타내는 부분

<br/>

##  검색키(search key) 또는 키(key)

검색키(search key or key) : 다른 레코드와 중복되지 않도록 각 레코드를 대표할 수 있는 필드

키는 하나의 필드로 이루어질 수도 있고, 두 개 이상의 필드로 이루어질 수도 있다

<br/>

##  검색 트리(search tree)

각 노드가 규칙에 맞도록 하나씩의 키를 갖고 있어서 해당 레코드가 저장된 위치를 알 수 있다

검색 트리는 이름과 같이 검색을 위한 자료구조로써 최대 몇 개의 자식 노드로 분기를 할 수 있느냐에 따라 이진 검색 트리 및 다진 검색 트리로 나뉨

<br/>

## Binary Search Tree(이진 검색 트리)

이진 검색 트리의 규칙은 다음과 같다 

1. 모든 노드는 서로 다른 키 값을 가진다 → 즉, 중복된 값은 없다

2. 모든 노드는 최대 두 개의 자식 노드만 가진다 → 자식의 수가 0,1,2 개 중 하나여야 함

3. 왼쪽 자식 < 부모 < 오른쪽 자식

<br/>

leaf node : 자식이 없는 노드 -> NIL (null) 로 간주

<br/> 

## Binary Search Tree(이진 검색 트리) 검색 알고리즘 

```ruby
treeSearch(t, x)
▷ t: 트리의 루트 노드
▷ x: 검색하고자 하는 키
{
    if (t = NIL or key[t] = x) then return t;
    if (x < key[t])
        then return treeSearch(left[t], x); ▷ 찾고자 하는 값이 현재 노드보다 작으면 → 왼쪽 자식 노드에서 계속 탐색
    else return treeSearch(right[t], x); ▷ 찾고자 하는 값이 현재 노드보다 크면 → 오른쪽 자식 노드로 이동
}
```

이진 검색 트리에서의 성공적인 검색은 record가 있는 노드에서 검색이 끝나고 원하는 record를 반환함

이진 검색 트리에서의 실패한 검색은 리프 노드에서조차 자식 노드로의 tree search를 호출하게 되며 따라서 NIL에서 반환하고 끝나게 됨

<br/>

## Binary Search Tree(이진 검색 트리) 검색 알고리즘 

```ruby
treeInsert(t, x) 
▷ t: 트리의 루트 노드
▷ x: 삽입하고자 하는 키
▷ 작업 완료 후 루트 노드의 포인터를 리턴한다
{ 
    if (t = NIL) then { 
        key[r] ← x; 
        left[r] ← NIL; 
        right[r] ← NIL;     ▷ r : 새 노드 
        return r; 
    } 
    if (x < key(t)) 
        then {left[t] ← treeInsert(left[t], x); return t;} 
        else {right[t] ← treeInsert(right[t], x); return t;}
}
```

<br/>

예시 : [30, 20, 25, 40, 10, 35] 순서대로 삽입하는 경우

![image](https://github.com/user-attachments/assets/3a2fd0dd-8b80-4d47-b7f0-88c8dc7c6b3f)

<br/>

## 이진검색 트리에서의 삽입 비재귀 버전

```ruby
treeInsert(t, x)
▷ t: 트리의 루트 노드
▷ x: 삽입하고자 하는 키
{
    key[r] ← x; 
    left[r] ← NIL; 
    right[r] ← NIL;     ▷ 새 노드 r를 만들고 x를 저장

    if (t = NIL) then ▷ 루트 노드가 비어 있으면 새 노드 r을 루트로 지정
        root ← r;
    else {
        p ← NIL; 
        tmp ← t;
        
        while (tmp ≠ NIL) { ▷ 재귀 부분을 while로 변경 
            p ← tmp;
            if (x < key[tmp]) then 
                tmp ← left[tmp];
            else 
                tmp ← right[tmp];
        }

        if (x < key[p]) then 
            left[p] ← r;
        else 
            right[p] ← r;
    }
}
```

위 while문 코드를 직관적으로 해석하면 p는 tmp의 부모 노드이다

tmp가 먼저 NIL에 도달하면 while이 종료되는데, 이 때, p가 leaf node에 도착하고, tmp가 p의 자식은 NIL에 도달한 상황이다 

마지막 if문에서 새로운 노드를 왼쪽에 넣을 것인지 오른쪽에 넣을 것인지 결정함











































