### 자연어 처리 정의 

- **자연어** : 인간이 일상적으로 사용하는 언어

- **자연어 처리** : 자연어 처리란 컴퓨터가 자연어를 기반으로 이 세상에 관해 뭔가를 배우고 이해할 수 있도록 자연어를 변환하고 처리하여 활용하는 기술 및 분야

<br/>

### 자연어 처리의 필요성 

- 컴퓨터라는 것 자체가 이미 프로그래밍 언어를 기반으로 동작하지만 자연어는 이와 완전히 다름

    - 프로그래밍 언어는 형식 언어의 일종으로 문법에 근거하여 파싱(parsing)하고 이를 번역 또는 해석이 가능함
 
    - 자연어는 문맥이 중요하기 때문에 **문법에만 근거해서 완전히 해석할 수 없으며**, 문법에도 예외가 존재 ex: "배"라는 말이 과일, 동물, 배(boat) 등 상황에 따라 달라짐
 
    - 자연어의 해석을 위해서는 배경지식이 필요한 경우도 많음 
  
<br/>

### 자연어 처리 발전 과정 

- **초창기**

    - 자연어 처리를 단순한 조건문/반복문, 문자열 매칭을 이용한 **패턴 기반 NLP**로 구현. 즉, 예전 챗봇은 단순 규칙에 따라서만 행동
 
    - 예를 들어, 입력에 “hello” 같은 단어 있으면 → “안녕하세요”라고 답하는 단순 챗봇이였음
 
    - 이것을 정규식으로 사용은 가능, 하지만 패턴 기반 NLP는 특정 상황에서는 작동하지만, **그 외 상황에서는 무력함**

    - 자연어 입력에 대한 의미를 컴퓨터가 파악하도록 하는 데는 무리가 있음 (ex: “배고프다”와 “밥 먹고 싶다”가 같은 뜻이라는 못 알아챔)

<br/>

### 간단한 챗봇 예시 

- 간단한 정규식으로 “hello/hi/hey” 같은 인사말이 입력에 있는지 확인

```ruby
>>> import re
>>> r = "(hi|hello|hey)[ ]*([a-z]*)"                                     # hi, hello, hey로 시작하고, 뒤에 공백과 알파벳이 올 수 있는 패턴을 만듦
>>> re.match(r, 'Hello Rosa', flags=re.IGNORECASE)                       # match : 문자열의 시작 부분부터 위에서 만든 정규식 패턴과 일치하는지 확인하는 함수
<_sre.SRE_Match object; span=(0, 10), match='Hello Rosa'>                # flags=re.IGNORECASE에 의해 대소문자 구분 x -> Rosa도 r의 규칙에 의해 match 가능
>>> re.match(r, "hi ho, hi ho, it's off to work ...", flags=re.IGNORECASE)
<_sre.SRE_Match object; span=(0, 5), match='hi ho'>
>>> re.match(r, "hey, what's up", flags=re.IGNORECASE)
<_sre.SRE_Match object; span=(0, 3), match='hey'>
```

<br/>

- 인사말 + 이름까지 매칭 (확장된 정규식)

```ruby
>>> r = r"[a-z]*(y|o|h)?ello|ok|hey|good[ ]?(morn[gin]{0,3}|afternoon|even[gin]{0,3})[\s,;:]{1,3}([a-z]{1,20})"  # 위 코드에서 r을 인사말과 이름을 감지할 수 있는 최소 패턴을 만든 것이고, 해당 r은 이것을 확장한 것 
>>> re_greeting = re.compile(r, flags=re.IGNORECASE)      # compile : 같은 정규식을 매번 해석하지 않고, 미리 번역된(컴파일된) 형태를 재사용이 가능함

>>> re_greeting.match("Hello Rosa")    # complie을 이용했기 때문에 ' re.match(r, 'Hello Rosa', flags=re.IGNORECASE)' 로 길게 쓰지 않고 간단한 코드 작성이 가능
<_sre.SRE_Match object; span=(0, 10), match='Hello Rosa'>

>>> re_greeting.match("Good morning Rosa")
<_sre.SRE_Match object; span=(0, 17), match='Good morning Rosa'>

>>> re_greeting.match("Good evening Rosa Parks").groups()
('Good evening', 'Rosa')

>>> re_greeting.match("yo Rosa")
<_sre.SRE_Match object; span=(0, 7), match='yo Rosa'>
```

<br/>

- if문으로 정중/무례 여부에 따라 응답이 다르게 함
  
```ruby
>>> my_names = set(['rosa', 'rose', 'chatty', 'chatbot', 'bot', 'chatterbot'])
>>> curt_names = set(['hal', 'you', 'u'])
>>> greeter_name = ''
>>> match = re_greeting.match(input())

>>> if match:
...     at_name = match.groups()[-1]
...     if at_name in curt_names:
...         print("Good one.")
...     elif at_name.lower() in my_names:
...         print("Hi {}, How are you?".format(greeter_name))
```

아래는 위와 같은 패턴기반NLP를 이용해서 1966년에 만들어진 규칙 기반 챗봇 ELIZA의 대화 예시이다

![System Resources](../../images/Natural%20Language%20Processing%20images/패턴기반NLP예시.png)

















