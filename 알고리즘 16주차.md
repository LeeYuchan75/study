## 상태공간트리 

**상태공간트리(State-Space Tree)** : 문제 해결 과정의 **중간 상태**를 각각 하나의 노드로 나타낸 트리를 의미

<br/>

### TSP 예시 

- 왼쪽 표: 각 도시 간 거리 행렬 (1~5 도시)

- 오른쪽 그래프: 도시 간 거리 기반의 완전 그래프 (각 도시 간 간선 있음)

![IMG_3439](https://github.com/user-attachments/assets/7333661c-fd57-4b0b-b8e4-dcd01f055e05)

![IMG_3438](https://github.com/user-attachments/assets/4a02e185-b536-46d2-aec1-ea984bbc002b)

해당 트리를 보면 다음과 같이 트리가 작성되었다 

- Depth 0 (루트): 1개 (1)

- Depth 1 (1-2, 1-3, 1-4, 1-5): 4개

- Depth 2 (예: 1-2-3, 1-2-4, ...): 12개 (각 depth 1 노드당 3개씩 → 4×3=12)

- Depth 3 (예: 1-2-3-4, 1-2-3-5, ...): 24개 (각 depth 2 노드당 2개씩 → 12×2=24)

각 계산은 경우의 수 이용 (1은 고정되어 있고 2,3,4,5 끼리 순서를 정하는 것 ex: Depth 3은 1은 고정되어 있고, 첫번째로 올 수 있는 수는 4개 다음은 3개 그 다음은 2개 -> 4x3x2 = 24)

<br/>

이렇게 트리로 중간중간의 상태를 나타낸 것을 **상태공간트리(State-Space Tree)** 라고 한다 

<br/>

## 백트래킹

**백트래킹(BackTracking)** : DFS 혹은 그와 유사한 스타일의 탐색을 총칭하는 용어

- 깊이 우선 탐색(DFS) 방식의 한 종류. 실패하거나 끝까지 갔을 때 되돌아가서 다른 경로를 시도하는 방식

- 상태공간트리를 DFS 방식으로 할 수 있는데까지 계속해서 탐색해가며 가능한 한 깊게 내려가다가 더 이상 갈 수 없으면 되돌아온 뒤, 다른 노드를 탐색

- 주로 재귀적으로 구현

<br/>

### 백트래킹 예시 

![IMG_3440](https://github.com/user-attachments/assets/b31e1e41-0e5e-4358-a4b4-6c565496d45b)

<br/>

### 미로찾기 백트래킹 알고리즘

```ruby
maze(v) {
    visited[v] ← YES;                  ▷ v 정점을 방문 표시
    if (v = T) then {print "성공!";}   ▷ 도착지(T)에 도달하면 성공 출력
    for each x ∈ L(v)                  ▷ 현재 정점 v에 인접한 모든 정점 x에 대해
        if (visited[x] = NO) then {    ▷ 아직 방문하지 않았다면
            prev[x] ← v;               ▷ 경로 추적용으로 이전 정점 저장 (돌아가는 길을 저장하기 위함)
            maze(x);                   ▷ 재귀적으로 다음 정점 탐색
        }
}
```

## 한정분기 

**한정분기(Branch-and-Bound)** : 경우의 수가 나누어지는 분기를 모두 다 수행하는것이 아니라, **한정된 수에 대해서**만 수행해서 탐색 효율을 높이는 방법을 의미 -> **가능성이 없는 분기는 애초에 제외**

**미리 계산된 근사해를 알고있어야** 하며, 따라서 아직 답안을 다 도출하기 전이라도 **이미 근사해보다 좋지 않은 결과가** 나올 것이 예정된 선택들은 더 이상 탐색하느라 **시간을 낭비하지 않고 선택지에서 제외**함

<br/>

### 백트래킹과의 공통점 및 차이점

**공통점** : 여러가지 경우들을 차례로 나열해야 함

**차이점** : 백트래킹은 더 이상 진행되지 않을 때까지 탐색을 수행하는 반면, **한정분기**에서는 최적해를 찾을 가능성이 없는 분기는 애초에 **제외**하게 됨

![image](https://github.com/user-attachments/assets/fcc42eed-95fa-4f02-86af-da0607047e37)

<br/>

### TSP & 한정분기 예시 

TSP에 대해 한정분기를 적용하는 예시를 살펴보기 전에, 리프노드가 아닌 노드에서 해당 노드를 거쳐가는 답안의 **하한값을 설정**하는 방식에 대해 설명하고자 한다 

- 각 노드와 이어진 간선 중 **가장 짧은 간선들**을 뽑으면 아래에서 빨간색으로 강조한 값이 됨

- 아래 빨간 원으로 표시한 것은 초기에 모든 노드를 순회할 수 있는 **최소 경로(하한값)** 을 정한 것

- 하한값 기준은 시작점에서 출발해서 다시 돌아오는 루트까지가 아니라 순회만 하는 기준

- **하한값을 설정하는 이유** : 더 볼 가치가 없는 경로”를 조기에 제거하기 위한 기준점을 만들기 위함 
  
![image](https://github.com/user-attachments/assets/3dc6221f-1b2a-4525-8f6f-034d129133d7)

<br/>

아래 과정을 보며 이해를 하자 

<br/>

![IMG_3455](https://github.com/user-attachments/assets/a4db90f7-71fc-4d8a-9eb1-5402b145b777)

<br/>

![IMG_3456](https://github.com/user-attachments/assets/c7829f57-9778-4a6c-82a7-2e53fe590aeb)

<br/>

![IMG_3457](https://github.com/user-attachments/assets/63f1c070-00ba-46ae-a65e-3b08b7214365)

<br/>

![IMG_3451](https://github.com/user-attachments/assets/c345f1b2-85f3-4a26-a9bf-f313a827f3b3)

<br/>

![IMG_3452](https://github.com/user-attachments/assets/1488a90d-c3da-45c7-8da3-46e486290e58)

<br/>

## A* 알고리즘

A* 알고리즘 : 그래프에서 두 지점간의 최단경로를 찾을 때 사용하는 알고리즘

- 다익스트라 알고리즘과 유사하지만, 다익스트라 알고리즘은 시작점이 주어지면 다른 모든 정점에 대한 최단거리를 구하기 때문에 정확히 두 지점간의 최단경로를 찾으려는 입장에선 효율적이지 않을 수 있음

- 상태공간트리 또한 그래프이므로 A* 알고리즘을 활용한 탐색이 가능

<br/>

### 최적우선탐색(Best-First Search)

- **최적우선탐색(Best-First Search)** 은 A* 알고리즘의 탐색 전략 -> **가장 가능성 있어 보이는 노드부터** 우선 방문
  
- 그래프 탐색 방식 중 하나로써 각 정점이 매력함수값 𝑔(𝑥)를 갖고 있음

- 방문하지 않은 정점들 중 𝑔(𝑥)값이 가장 매력적인 정점들부터 방문하는 방식

- 우리가 일반적으로 알고 있는 너비 우선 탐색(Breadth-First Search)의 BFS와 헷갈리지 않게 조심

<br/>

### A* 알고리즘의 수식적 정의와 조건

- 다익스트라에서 g(x): 시작점에서 해당 정점까지 거리 (현재까지 계산된 )

- 프림 알고리즘에서의 𝑔(𝑥): 해당 정점을 현재의 최소신장트리 집합과 연결하기 위한 거리

- A* 알고리즘에서의 𝑔(𝑥): 시작점에서 해당 정점까지의 거리(현재까지 계산된 값) + ℎ(𝑥)

- h(x): 목적지까지 남은 거리의 추정값 (예: 직선거리)

<br/>

- A* 알고리즘에서는 매력함수값 계산을 위해 **추정 잔여거리 ℎ(𝑥)** 를 활용하며, 이 때 **ℎ(𝑥)는 실제 해당 정점과 목적지까지의 거리보다 크면 안 됨**

- 즉, 모든정점쌍 (x,y) 에대해 h(x) ≤ w(x,y) + h(y) 를 만족해야 함

- 다익스트라 알고리즘에서는 모든 ℎ(𝑥)가0인 상황 -> A* 알고리즘에서 f(x) = g(x) + h(x)로 계산 -> 여기서 다익스트라는 목표 지점까지 고려하지 않으므로 h(x) = 0 


























































